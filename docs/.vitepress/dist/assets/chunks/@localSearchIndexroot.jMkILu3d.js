const e='{"documentCount":69,"nextId":69,"documentIds":{"0":"/api-examples.html#runtime-api-examples","1":"/api-examples.html#results","2":"/api-examples.html#theme-data","3":"/api-examples.html#page-data","4":"/api-examples.html#page-frontmatter","5":"/api-examples.html#more","6":"/guide/backend/aboutGit.html#git常用操作","7":"/guide/backend/aboutGit.html#同步master","8":"/guide/backend/aboutGit.html#合并多个commit","9":"/guide/backend/aboutGit.html#cherry-pick","10":"/guide/backend/aboutGit.html#其他","11":"/guide/backend/aboutGit.html#优秀文章","12":"/guide/backend/crossEntropy.html#交叉熵","13":"/guide/backend/crossEntropy.html#信息论","14":"/guide/backend/crossEntropy.html#_1-信息量","15":"/guide/backend/crossEntropy.html#_2-熵","16":"/guide/backend/crossEntropy.html#_3-相对熵-kl散度","17":"/guide/backend/crossEntropy.html#_4-交叉熵","18":"/guide/backend/crossEntropy.html#机器学习中交叉熵的应用","19":"/guide/backend/crossEntropy.html#_1-交叉熵在单分类问题中的使用","20":"/guide/backend/crossEntropy.html#_2-交叉熵在多分类问题中的使用","21":"/guide/backend/#技术学习","22":"/guide/backend/#关于笔者","23":"/guide/backend/knn.html#第2章-k-近邻算法","24":"/guide/backend/knn.html#knn-概述","25":"/guide/backend/knn.html#knn-场景","26":"/guide/backend/knn.html#knn-原理","27":"/guide/backend/knn.html#knn-项目案例","28":"/guide/backend/knn.html#项目案例1-优化约会网站的配对效果","29":"/guide/backend/knn.html#项目概述","30":"/guide/backend/knn.html#开发流程","31":"/guide/backend/knn.html#项目案例2-手写数字识别系统","32":"/guide/backend/knn.html#项目概述-1","33":"/guide/backend/knn.html#开发流程-1","34":"/guide/backend/knn.html#knn-小结","35":"/guide/backend/knn.html#基本原理","36":"/guide/backend/knn.html#knn-三要素","37":"/guide/backend/knn.html#算法-sklearn-上有三种","38":"/guide/cs/algorithm/orderOfTree.html#_1-二叉树的遍历","39":"/guide/cs/algorithm/orderOfTree.html#_1-1-定义","40":"/guide/cs/algorithm/orderOfTree.html#_1-2-遍历方式","41":"/guide/cs/algorithm/orderOfTree.html#_1-3-遍历实现","42":"/guide/cs/algorithm/orderOfTree.html#_5-3-1-前序遍历","43":"/guide/cs/algorithm/orderOfTree.html#_5-3-2-中序遍历","44":"/guide/cs/algorithm/orderOfTree.html#_5-3-3-后序遍历","45":"/guide/cs/algorithm/orderOfTree.html#_5-3-4-层序遍历","46":"/guide/cs/algorithm/orderOfTree.html#_5-4-遍历方式总结","47":"/guide/cs/#技术学习","48":"/guide/cs/#关于笔者","49":"/guide/cs/os/indexOfMysql.html#mysql数据库之索引","50":"/guide/cs/os/indexOfMysql.html#一、索引使用篇","51":"/guide/cs/os/indexOfMysql.html#i、索引有什么好处","52":"/guide/cs/os/indexOfMysql.html#ii、索引有什么坏处","53":"/guide/cs/os/indexOfMysql.html#iii、索引的使用场景","54":"/guide/cs/os/indexOfMysql.html#iv、索引的类型","55":"/guide/cs/os/indexOfMysql.html#v、mysql-索引的-创建-原则","56":"/guide/cs/os/indexOfMysql.html#vi、mysql-索引的-使用-注意事项","57":"/guide/cs/os/indexOfMysql.html#二、索引原理篇","58":"/guide/cs/os/indexOfMysql.html#_1-b-tree索引","59":"/guide/cs/os/indexOfMysql.html#_2-哈希索引","60":"/guide/resume/Resume.html#个人信息","61":"/guide/resume/Resume.html#教育经历","62":"/guide/resume/Resume.html#工作经历","63":"/guide/resume/Resume.html#项目经历","64":"/guide/resume/Resume.html#技能清单","65":"/markdown-examples.html#markdown-extension-examples","66":"/markdown-examples.html#syntax-highlighting","67":"/markdown-examples.html#custom-containers","68":"/markdown-examples.html#more"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[3,1,51],"1":[1,3,1],"2":[2,4,2],"3":[2,4,2],"4":[2,4,2],"5":[1,3,11],"6":[1,1,1],"7":[1,1,10],"8":[1,1,24],"9":[2,1,54],"10":[1,1,18],"11":[1,1,11],"12":[1,1,6],"13":[1,1,1],"14":[2,2,28],"15":[2,2,41],"16":[4,2,37],"17":[2,2,18],"18":[1,1,1],"19":[2,2,19],"20":[2,2,31],"21":[1,1,1],"22":[1,1,11],"23":[3,1,1],"24":[2,3,28],"25":[2,3,37],"26":[2,3,54],"27":[2,3,1],"28":[2,5,1],"29":[1,7,13],"30":[1,7,349],"31":[2,5,1],"32":[1,7,13],"33":[1,7,126],"34":[2,3,9],"35":[1,5,12],"36":[2,5,85],"37":[4,5,204],"38":[2,1,1],"39":[2,3,40],"40":[3,3,8],"41":[3,3,6],"42":[4,4,73],"43":[4,3,66],"44":[3,3,72],"45":[4,3,54],"46":[3,3,1],"47":[1,1,1],"48":[1,1,11],"49":[1,1,1],"50":[2,1,9],"51":[3,3,10],"52":[3,3,11],"53":[3,3,34],"54":[3,3,27],"55":[6,3,21],"56":[6,3,52],"57":[2,1,10],"58":[2,3,460],"59":[2,3,130],"60":[1,1,6],"61":[1,1,13],"62":[1,1,10],"63":[1,1,10],"64":[1,1,13],"65":[3,1,14],"66":[2,3,26],"67":[2,3,21],"68":[1,3,11]},"averageFieldLength":[2.0434782608695654,2.6231884057971016,36.768115942028984],"storedFields":{"0":{"title":"Runtime API Examples","titles":[]},"1":{"title":"Results","titles":["Runtime API Examples"]},"2":{"title":"Theme Data","titles":["Runtime API Examples","Results"]},"3":{"title":"Page Data","titles":["Runtime API Examples","Results"]},"4":{"title":"Page Frontmatter","titles":["Runtime API Examples","Results"]},"5":{"title":"More","titles":["Runtime API Examples"]},"6":{"title":"git常用操作","titles":[]},"7":{"title":"同步master","titles":["git常用操作"]},"8":{"title":"合并多个commit","titles":["git常用操作"]},"9":{"title":"cherry-pick","titles":["git常用操作"]},"10":{"title":"其他","titles":["git常用操作"]},"11":{"title":"优秀文章","titles":["git常用操作"]},"12":{"title":"交叉熵","titles":[]},"13":{"title":"信息论","titles":["交叉熵"]},"14":{"title":"1 信息量","titles":["交叉熵","信息论"]},"15":{"title":"2 熵","titles":["交叉熵","信息论"]},"16":{"title":"3 相对熵（KL散度）","titles":["交叉熵","信息论"]},"17":{"title":"4 交叉熵","titles":["交叉熵","信息论"]},"18":{"title":"机器学习中交叉熵的应用","titles":["交叉熵"]},"19":{"title":"1 交叉熵在单分类问题中的使用","titles":["交叉熵","机器学习中交叉熵的应用"]},"20":{"title":"2 交叉熵在多分类问题中的使用","titles":["交叉熵","机器学习中交叉熵的应用"]},"21":{"title":"技术学习","titles":[]},"22":{"title":"关于笔者","titles":["技术学习"]},"23":{"title":"第2章 k-近邻算法","titles":[]},"24":{"title":"KNN 概述","titles":["第2章 k-近邻算法"]},"25":{"title":"KNN 场景","titles":["第2章 k-近邻算法"]},"26":{"title":"KNN 原理","titles":["第2章 k-近邻算法"]},"27":{"title":"KNN 项目案例","titles":["第2章 k-近邻算法"]},"28":{"title":"项目案例1: 优化约会网站的配对效果","titles":["第2章 k-近邻算法","KNN 项目案例"]},"29":{"title":"项目概述","titles":["第2章 k-近邻算法","KNN 项目案例","项目案例1: 优化约会网站的配对效果"]},"30":{"title":"开发流程","titles":["第2章 k-近邻算法","KNN 项目案例","项目案例1: 优化约会网站的配对效果"]},"31":{"title":"项目案例2: 手写数字识别系统","titles":["第2章 k-近邻算法","KNN 项目案例"]},"32":{"title":"项目概述","titles":["第2章 k-近邻算法","KNN 项目案例","项目案例2: 手写数字识别系统"]},"33":{"title":"开发流程","titles":["第2章 k-近邻算法","KNN 项目案例","项目案例2: 手写数字识别系统"]},"34":{"title":"KNN 小结","titles":["第2章 k-近邻算法"]},"35":{"title":"基本原理","titles":["第2章 k-近邻算法","KNN 小结"]},"36":{"title":"KNN 三要素","titles":["第2章 k-近邻算法","KNN 小结"]},"37":{"title":"算法：（sklearn 上有三种）","titles":["第2章 k-近邻算法","KNN 小结"]},"38":{"title":"1. 二叉树的遍历","titles":[]},"39":{"title":"1.1 定义","titles":["1. 二叉树的遍历",null]},"40":{"title":"1.2 遍历方式","titles":["1. 二叉树的遍历",null]},"41":{"title":"1.3 遍历实现","titles":["1. 二叉树的遍历",null]},"42":{"title":"5.3.1 前序遍历","titles":["1. 二叉树的遍历",null,"1.3 遍历实现"]},"43":{"title":"5.3.2 中序遍历","titles":["1. 二叉树的遍历",null]},"44":{"title":"5.3.3 后序遍历","titles":["1. 二叉树的遍历",null]},"45":{"title":"5.3.4 层序遍历","titles":["1. 二叉树的遍历",null]},"46":{"title":"5.4 遍历方式总结","titles":["1. 二叉树的遍历",null]},"47":{"title":"技术学习","titles":[]},"48":{"title":"关于笔者","titles":["技术学习"]},"49":{"title":"MySql数据库之索引","titles":[null,null]},"50":{"title":"一、索引使用篇","titles":[null,null]},"51":{"title":"I、索引有什么好处？","titles":[null,null,"一、索引使用篇"]},"52":{"title":"II、索引有什么坏处？","titles":[null,null,"一、索引使用篇"]},"53":{"title":"III、索引的使用场景？","titles":[null,null,"一、索引使用篇"]},"54":{"title":"IV、索引的类型？","titles":[null,null,"一、索引使用篇"]},"55":{"title":"V、MySQL 索引的“创建”原则？","titles":[null,null,"一、索引使用篇"]},"56":{"title":"VI、MySQL 索引的“使用”注意事项？","titles":[null,null,"一、索引使用篇"]},"57":{"title":"二、索引原理篇","titles":[null,null]},"58":{"title":"1.B+Tree索引","titles":[null,null,"二、索引原理篇"]},"59":{"title":"2.哈希索引","titles":[null,null,"二、索引原理篇"]},"60":{"title":"个人信息","titles":[null]},"61":{"title":"教育经历","titles":[null]},"62":{"title":"工作经历","titles":[null]},"63":{"title":"项目经历","titles":[null]},"64":{"title":"技能清单","titles":[null]},"65":{"title":"Markdown Extension Examples","titles":[]},"66":{"title":"Syntax Highlighting","titles":["Markdown Extension Examples"]},"67":{"title":"Custom Containers","titles":["Markdown Extension Examples"]},"68":{"title":"More","titles":["Markdown Extension Examples"]}},"dirtCount":0,"index":[["```",{"2":{"66":1}}],["★☆☆",{"2":{"64":1}}],["★★☆",{"2":{"64":3}}],["★★★",{"2":{"64":3}}],["技能清单",{"0":{"64":1}}],["技术学习",{"0":{"21":1,"47":1},"1":{"22":1,"48":1}}],["尽量用数据来说明",{"2":{"63":1}}],["解决了什么问题",{"2":{"63":1}}],["解析信号并定位到指定存储单元",{"2":{"58":1}}],["解析文本文件",{"2":{"30":2}}],["负责",{"2":{"62":1}}],["工程师",{"2":{"62":1}}],["工作经历",{"0":{"62":1}}],["工作日与魅力一般的人约会",{"2":{"29":1}}],["工作原理",{"2":{"26":1}}],["部门",{"2":{"62":1}}],["部分",{"2":{"36":1}}],["公司",{"2":{"62":1}}],["英语等级考试",{"2":{"61":1}}],["年级前",{"2":{"61":1}}],["年出生",{"2":{"60":1}}],["绩点",{"2":{"61":1}}],["软件工程专业",{"2":{"61":1}}],["东莞理工学院",{"2":{"61":1}}],["学士",{"2":{"61":1}}],["学习",{"2":{"36":2}}],["教育经历",{"0":{"61":1}}],["男",{"2":{"60":1}}],["附录",{"2":{"59":1}}],["经过哈希算法后",{"2":{"59":1}}],["经过一段时间之后",{"2":{"29":1}}],["键值都是唯一的",{"2":{"59":1}}],["键值的数据的记录条数",{"2":{"59":1}}],["速度非常快",{"2":{"59":1}}],["速度会非常快",{"2":{"58":1}}],["检索时不需要类似b+树那样从根节点到叶子节点逐级查找",{"2":{"59":1}}],["把键值换算成新的哈希值",{"2":{"59":1}}],["把所有训练的点之间的距离都算一遍",{"2":{"37":1}}],["运算之后",{"2":{"59":1}}],["运算之后的",{"2":{"59":1}}],["运算前的键值完全一样",{"2":{"59":1}}],["运维的坑",{"2":{"53":1}}],["任何事物都是有两面性的",{"2":{"59":1}}],["任何方法",{"2":{"26":2}}],["既然",{"2":{"59":1}}],["十分低效",{"2":{"58":1}}],["再例如",{"2":{"58":1}}],["再加上机械运动耗费",{"2":{"58":1}}],["过长的主索引会令辅助索引变得过大",{"2":{"58":1}}],["了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助",{"2":{"58":1}}],["图11为定义在col3上的一个辅助索引",{"2":{"58":1}}],["首先检索辅助索引获得主键",{"2":{"58":1}}],["首先归一化是为了后面数据处理的方便",{"2":{"30":1}}],["聚集索引这种实现方式使得按主键的搜索十分高效",{"2":{"58":1}}],["聚簇索引表最大限度地提高了",{"2":{"58":1}}],["聚簇索引主要用在innodb存储引擎中",{"2":{"58":1}}],["类型为长整形",{"2":{"58":1}}],["节点的数据可以存储更多主键",{"2":{"58":1}}],["节点的键值可以存储更多主键",{"2":{"58":1}}],["第二个与myisam索引的不同是innodb的辅助索引data域存储相应记录主键的值而不是地址",{"2":{"58":1}}],["第二次根据主键值找到行数据",{"2":{"58":1}}],["第一个重大区别是innodb的数据文件本身就是索引文件",{"2":{"58":1}}],["第一次找到主键值",{"2":{"58":1}}],["第2章",{"0":{"23":1},"1":{"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":1,"34":1,"35":1,"36":1,"37":1}}],["默认情况下",{"2":{"58":1}}],["又或者为什么主键需要带有时间性关联",{"2":{"58":1}}],["列为主键",{"2":{"58":1}}],["列类型是字符串类型",{"2":{"56":1}}],["严重影响性能",{"2":{"58":1}}],["插入速度严重依赖于插入顺序",{"2":{"58":1}}],["密集型应用的性能",{"2":{"58":1}}],["之所以这么称呼是为了与innodb的聚簇索引区分",{"2":{"58":1}}],["之间是一种链式环结构",{"2":{"58":1}}],["读取相应数据记录",{"2":{"58":1}}],["示意",{"2":{"58":1}}],["叶节点的data域存放的是数据记录的地址",{"2":{"58":1}}],["次磁盘",{"2":{"58":1}}],["次数",{"2":{"58":1}}],["层",{"2":{"58":1}}],["层序遍历",{"0":{"45":1},"2":{"40":1}}],["条记录",{"2":{"58":1}}],["^3",{"2":{"58":1}}],["^2",{"2":{"30":3}}],["指针类型也一般为",{"2":{"58":1}}],["指定",{"2":{"8":1}}],["占用8个字节",{"2":{"58":1}}],["占用4个字节",{"2":{"58":1}}],["占用存储空间",{"2":{"52":1}}],["存储引擎在设计时是将根节点常驻内存的",{"2":{"58":1}}],["存储引擎中页的大小为",{"2":{"58":1}}],["存树结构的内存变小",{"2":{"37":1}}],["让我们能够更直接的看出b+tree的优点",{"2":{"58":1}}],["操作系统一般将内存和磁盘分割成固定大小的块",{"2":{"58":1}}],["操作",{"2":{"58":2}}],["操作符",{"2":{"56":1}}],["利用磁盘预读特性",{"2":{"58":1}}],["查找的次数也就更多",{"2":{"58":1}}],["查询",{"2":{"56":1,"59":1}}],["查询时一定要给值加引号",{"2":{"56":1}}],["查询时间",{"2":{"37":1}}],["查询时间越慢",{"2":{"37":1}}],["查询点较多的时候可以使用树结构算法",{"2":{"37":1}}],["查询点较少的时候用brute",{"2":{"37":1}}],["查询点数量",{"2":{"37":1}}],["查询所需消耗",{"2":{"37":1}}],["查询速度有很大的提升",{"2":{"37":1}}],["大非常多",{"2":{"58":1}}],["大部分情况下全表扫描效率更高",{"2":{"53":1}}],["为什么大家不都用",{"2":{"59":1}}],["为什么主键需要是自增",{"2":{"58":1}}],["为方便计算",{"2":{"58":1}}],["为每个节点的出度",{"2":{"58":1}}],["为了减少磁盘",{"2":{"58":1}}],["为了达到这个目的",{"2":{"58":2}}],["为了实现这一点",{"2":{"58":1}}],["为了读取这个扇区的数据",{"2":{"58":1}}],["为了简单起见",{"2":{"58":1}}],["效率明显比b",{"2":{"58":1}}],["效果拔群",{"2":{"36":1}}],["无法利用局部性",{"2":{"58":1}}],["无数据输入假定",{"2":{"26":1}}],["物理上可能很远",{"2":{"58":1}}],["父子",{"2":{"58":1}}],["另一种是从根节点开始",{"2":{"58":1}}],["另一个指向关键字最小的叶子节点",{"2":{"58":1}}],["另外距离",{"2":{"37":1}}],["除此之外",{"2":{"58":1}}],["进行随机查找",{"2":{"58":1}}],["进行两种查找运算",{"2":{"58":1}}],["进而影响查询效率",{"2":{"58":1}}],["进阶版",{"2":{"37":1}}],["增大查询时的磁盘",{"2":{"58":1}}],["能存储的",{"2":{"58":1}}],["还是要通过访问表中的实际数据进行相应的比较",{"2":{"59":1}}],["还有",{"2":{"58":1}}],["还可以是",{"2":{"36":1}}],["结构图中可以看到",{"2":{"58":1}}],["综上所述",{"2":{"58":1}}],["渐进复杂度为o",{"2":{"58":1}}],["根节点常驻内存",{"2":{"58":1}}],["根据b",{"2":{"58":1}}],["根据情况创建复合索引",{"2":{"55":1}}],["根据制定的半径来找寻邻点",{"2":{"37":1}}],["根据其",{"2":{"24":1}}],["加之计算机存储分配都是按页对齐的",{"2":{"58":1}}],["先从b",{"2":{"58":1}}],["先取a0再取a1和先取a0再取d3的时间消耗是一样的",{"2":{"58":1}}],["程序继续运行",{"2":{"58":1}}],["页得大小通常为4k",{"2":{"58":1}}],["页是计算机管理存储器的逻辑块",{"2":{"58":1}}],["硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块",{"2":{"58":1}}],["预读过程中",{"2":{"58":1}}],["预读的长度一般为页",{"2":{"58":1}}],["预读可以提高i",{"2":{"58":1}}],["预测就会出错",{"2":{"36":1}}],["预测结果会对近邻的实例点非常敏感",{"2":{"36":1}}],["由于不同索引键存在相同",{"2":{"59":1}}],["由于",{"2":{"59":2}}],["由于逻辑上很近的节点",{"2":{"58":1}}],["由于磁盘顺序读取的效率很高",{"2":{"58":1}}],["由于存储介质的特性",{"2":{"58":1}}],["顺序读取不需要进行磁盘寻道",{"2":{"58":1}}],["顺序向后读取一定长度的数据放入内存",{"2":{"58":1}}],["顺序很重要",{"2":{"9":1}}],["要尽量减少磁盘i",{"2":{"58":1}}],["局部性原理与磁盘预读",{"2":{"58":1}}],["哪个扇区",{"2":{"58":1}}],["系统会将数据逻辑地址传给磁盘",{"2":{"58":1}}],["系统将要写入单元地址和数据分别放在地址总线和数据总线上",{"2":{"58":1}}],["圆心是盘片中心",{"2":{"58":1}}],["盘片被划分成一系列同心环",{"2":{"58":1}}],["所谓聚簇索引",{"2":{"58":1}}],["所耗费时间叫做寻道时间",{"2":{"58":1}}],["所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上",{"2":{"58":1}}],["所有半径相同的磁道组成一个柱面",{"2":{"58":1}}],["所有磁头任何时候都是重叠的",{"2":{"58":1}}],["所以即使取满足某个",{"2":{"59":1}}],["所以通过组合索引的前面一个或几个索引键进行查询的时候",{"2":{"59":1}}],["所以数据库无法利用索引的数据来避免任何排序运算",{"2":{"59":1}}],["所以它只能用于等值的过滤",{"2":{"59":1}}],["所以",{"2":{"59":1}}],["所以innodb要求表必须有主键",{"2":{"58":1}}],["所以红黑树的树高",{"2":{"58":1}}],["所以红黑树的i",{"2":{"58":1}}],["所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘i",{"2":{"58":1}}],["所以不同存储引擎具有不同的索引类型和实现",{"2":{"57":1}}],["所以这个过程是没有必要的",{"2":{"30":1,"33":1}}],["所以是一个二项分布",{"2":{"20":1}}],["所以一般在机器学习中直接用用交叉熵做loss",{"2":{"17":1}}],["所以上面电脑开机问题的熵为",{"2":{"15":1}}],["所以顺序是我提交",{"2":{"9":1}}],["磁道被沿半径线划分成一个个小的段",{"2":{"58":1}}],["磁头需要移动对准相应磁道",{"2":{"58":1}}],["磁头不能转动",{"2":{"58":1}}],["磁头支架固定了一组磁头",{"2":{"58":1}}],["磁盘进行顺序读取",{"2":{"58":1}}],["磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中",{"2":{"58":1}}],["磁盘也会从这个位置开始",{"2":{"58":1}}],["磁盘往往不是严格按需读取",{"2":{"58":2}}],["磁盘的存取速度往往是主存的几百分分之一",{"2":{"58":1}}],["磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址",{"2":{"58":1}}],["磁盘本身存取就比主存慢很多",{"2":{"58":1}}],["磁盘可以转动",{"2":{"58":1}}],["磁盘i",{"2":{"58":1}}],["磁盘存取原理",{"2":{"58":1}}],["两次存取的数据的",{"2":{"58":1}}],["做相应的写操作",{"2":{"58":1}}],["写主存的过程类似",{"2":{"58":1}}],["供其它部件读取",{"2":{"58":1}}],["抽象出一个十分简单的存取模型来说明ram的工作原理",{"2":{"58":1}}],["现代主存的编址规则比较复杂",{"2":{"58":1}}],["现代ram的结构和存取原理比较复杂",{"2":{"58":1}}],["现在她收集到了一些约会网站未曾记录的数据信息",{"2":{"29":1}}],["现在根据上面我们得到的样本集中所有电影与未知电影的距离",{"2":{"25":1}}],["现在想把test的第2次提交",{"2":{"9":1}}],["目前计算机使用的主存基本都是随机读写存储器",{"2":{"58":1}}],["目前解决方案有",{"2":{"53":1}}],["上有两个头指针",{"2":{"58":1}}],["上有三种",{"0":{"37":1}}],["上文说过",{"2":{"58":1}}],["上面讲的所有查询算法都是假设数据存储在计算机主存中的",{"2":{"58":1}}],["具体它们之间的差别后面会详细介绍",{"2":{"58":1}}],["具有不同爱好的人其类别区域也不同",{"2":{"30":1}}],["外部磁盘的数据读取速率要比主从慢好几个数量级",{"2":{"58":1}}],["外键索引",{"2":{"54":1}}],["红黑树的出度为",{"2":{"58":1}}],["红黑树等平衡树也可以用来实现索引",{"2":{"58":1}}],["红黑树等数据结构也可以用来实现索引",{"2":{"58":1}}],["红黑树",{"2":{"58":1}}],["平衡树查找操作的时间复杂度和树高",{"2":{"58":1}}],["平衡二叉树",{"2":{"58":1}}],["平时喜欢写一些小玩具",{"2":{"22":1,"48":1}}],["哈希索引的效率也是极低的",{"2":{"59":1}}],["哈希索引也不支持多列联合索引的最左匹配规则",{"2":{"59":1}}],["哈希索引也没办法利用索引完成排序",{"2":{"59":1}}],["哈希索引就是采用一定的哈希算法",{"2":{"59":1}}],["哈希索引",{"0":{"59":1},"2":{"57":1}}],["评估使用索引比全表扫描更慢",{"2":{"56":1}}],["评估模型",{"2":{"17":1}}],["算术运算或其他表达式运算",{"2":{"56":1}}],["算法处理之后的",{"2":{"59":1}}],["算法流程图",{"2":{"45":1}}],["算法其实就是",{"2":{"37":1}}],["算法",{"0":{"37":1}}],["算法伪代码",{"2":{"30":1}}],["算法特点",{"2":{"26":1,"37":1}}],["算法按照距离最近的三部电影的类型",{"2":{"25":1}}],["算法是一种基本分类与回归方法",{"2":{"24":1}}],["左边进行函数",{"2":{"56":1}}],["左孩子",{"2":{"39":2}}],["注意",{"2":{"56":1}}],["注意事项",{"0":{"56":1}}],["否则索引失效",{"2":{"56":1}}],["否则索引指向的物理数据可能不对",{"2":{"52":1}}],["否则系统将可能无法正确使用索引",{"2":{"56":1}}],["否则将会出现页分裂",{"2":{"58":1}}],["否则将导致引擎放弃使用索引而进行全表扫描",{"2":{"56":1}}],["否则将引擎放弃使用索引而进行全表扫描",{"2":{"56":1}}],["子句中的",{"2":{"56":1}}],["子句中的列",{"2":{"55":1}}],["子句中对字段进行函数操作",{"2":{"56":1}}],["子句中对字段进行表达式操作",{"2":{"56":1}}],["子句中使用",{"2":{"56":2}}],["应尽量避免在",{"2":{"56":4}}],["应该定制一个前缀长度",{"2":{"55":1}}],["应用场景傻傻分不清楚",{"2":{"37":1}}],["避免创建过多的索引",{"2":{"55":1}}],["关键字后的列",{"2":{"55":1}}],["关于这一点",{"2":{"58":1}}],["关于",{"2":{"37":1}}],["关于笔者",{"0":{"22":1,"48":1}}],["或",{"2":{"56":1,"58":2}}],["或连接子句中的列",{"2":{"55":1}}],["或者",{"2":{"36":1}}],["创建",{"0":{"55":1}}],["创建队列",{"2":{"45":1}}],["全文索引等等",{"2":{"57":1}}],["全文索引",{"2":{"54":1}}],["完整性和实现级联操作",{"2":{"54":1}}],["保证数据的一致性",{"2":{"54":1}}],["复合索引遵循前缀原则",{"2":{"56":1}}],["复合索引可以提高查询效率",{"2":{"55":1}}],["复合索引",{"2":{"54":1}}],["特殊的唯一索引",{"2":{"54":1}}],["特大型的表",{"2":{"53":1}}],["主索引和辅助索引没啥区别",{"2":{"58":1}}],["主索引和辅助索引",{"2":{"58":1}}],["主存和磁盘以页为单位交换数据",{"2":{"58":1}}],["主存存取的时间仅与存取次数呈线性关系",{"2":{"58":1}}],["主存存取原理",{"2":{"58":1}}],["主存读取两个总线的内容",{"2":{"58":1}}],["主存读到地址信号后",{"2":{"58":1}}],["主存的存取过程如下",{"2":{"58":1}}],["主存的读取速度快",{"2":{"58":1}}],["主存是一系列的存储单元组成的矩阵",{"2":{"58":1}}],["主键",{"2":{"58":1}}],["主键是允许更新的",{"2":{"58":1}}],["主键尽可能选择较短的数据类型",{"2":{"55":1}}],["主键索引",{"2":{"54":1}}],["主要用在myisam存储引擎中",{"2":{"58":1}}],["主要用在innodb存储引擎中",{"2":{"58":1}}],["主要有以下这些",{"2":{"59":1}}],["主要有以下两个原因",{"2":{"58":1}}],["主要有六种类型",{"2":{"54":1}}],["主要采用",{"2":{"42":1,"43":1,"44":1}}],["唯一索引",{"2":{"54":1}}],["普通索引",{"2":{"54":1}}],["都是实现在存储引擎层的",{"2":{"54":1}}],["都不确定mysql是怎么玩的",{"2":{"53":1}}],["嘿嘿",{"2":{"53":1}}],["研发写了一个sql",{"2":{"53":1}}],["研究技术",{"2":{"22":1,"48":1}}],["可能很多人又有疑问了",{"2":{"59":1}}],["可能很多人有疑问很多数据结构都能优化查询速度",{"2":{"58":1}}],["可能面试官会换一个问法",{"2":{"58":1}}],["可知检索一次最多需要访问h个节点",{"2":{"58":1}}],["可不受此限制",{"2":{"58":1}}],["可控",{"2":{"53":1}}],["可以看出myisam的索引文件仅仅保存数据记录的地址",{"2":{"58":1}}],["可以使用全文索引",{"2":{"56":1}}],["可以使用分区技术来解决",{"2":{"53":1}}],["可以在语句中添加强制索引",{"2":{"56":1}}],["可以节省大量的索引空间",{"2":{"55":1}}],["可以有效减少索引的磁盘占用提高查询效率",{"2":{"55":1}}],["可以覆盖多个列",{"2":{"54":1}}],["可以移除某些影响分类的特征",{"2":{"37":1}}],["可以通过shrink",{"2":{"37":1}}],["可以通过weight",{"2":{"37":1}}],["可以选择",{"2":{"37":1}}],["可以来选择",{"2":{"37":1}}],["可以直接使用",{"2":{"37":1}}],["可以用交叉验证",{"2":{"36":1}}],["可以找到",{"2":{"25":1}}],["可以取多类",{"2":{"24":1}}],["可以计算出每个可能性的信息量",{"2":{"15":1}}],["可以指定是否复原索引或工作树的内容",{"2":{"10":1}}],["自带的全文索引只能用于",{"2":{"54":1}}],["自己掌控业务场景与访问模式",{"2":{"53":1}}],["自己分库分表",{"2":{"53":1}}],["自动为您选择最优算法",{"2":{"37":1}}],["很明显比",{"2":{"58":1}}],["很容易出现全表锁",{"2":{"53":1}}],["很多人都知道",{"2":{"50":1}}],["等等",{"2":{"53":1}}],["等式的后一部分",{"2":{"17":1}}],["等式的前一部分恰巧就是p的熵的相反数",{"2":{"17":1}}],["记录了主键与索引字段",{"2":{"52":1}}],["降低",{"2":{"58":1}}],["降低写操作效率",{"2":{"55":1}}],["降低更新表的速度",{"2":{"52":1}}],["降低cpu消耗",{"2":{"51":1}}],["降低数据排序的成本",{"2":{"51":1}}],["降低数据库io成本",{"2":{"51":1}}],["提高数据的检索速度",{"2":{"51":1}}],["提供文本文件",{"2":{"30":2,"33":2}}],["索引遇到大量hash值相等的情况后性能并不一定就会比b",{"2":{"59":1}}],["索引中直接完成查询",{"2":{"59":1}}],["索引中存放的是经过",{"2":{"59":1}}],["索引在任何时候都不能避免表扫描",{"2":{"59":1}}],["索引在计算",{"2":{"59":1}}],["索引也无法被利用",{"2":{"59":1}}],["索引也一样",{"2":{"59":1}}],["索引不能利用部分索引键查询",{"2":{"59":1}}],["索引无法被用来避免数据的排序操作",{"2":{"59":1}}],["索引比较的是进行",{"2":{"59":1}}],["索引仅仅能满足",{"2":{"59":1}}],["索引本身由于其特殊性也带来了很多限制和弊端",{"2":{"59":1}}],["索引本身也很大",{"2":{"58":1}}],["索引效率高",{"2":{"59":1}}],["索引效果越好",{"2":{"55":1}}],["索引呢",{"2":{"59":1}}],["索引而还要使用",{"2":{"59":1}}],["索引需要从根节点到枝节点",{"2":{"59":1}}],["索引结构的特殊性",{"2":{"59":1}}],["索引文件仅保存数据记录的地址",{"2":{"58":1}}],["索引可以维护10^3",{"2":{"58":1}}],["索引可以大大加快查询的速度",{"2":{"50":1}}],["索引检索需要磁盘i",{"2":{"58":1}}],["索引一般以文件形式存储在磁盘上",{"2":{"58":1}}],["索引查找过程中就要产生磁盘i",{"2":{"58":1}}],["索引是将索引键通过",{"2":{"59":1}}],["索引是在存储引擎层实现的",{"2":{"57":1}}],["索引是一个排序的列表",{"2":{"50":1}}],["索引原理篇",{"0":{"57":1},"1":{"58":1,"59":1}}],["索引会额外占用磁盘空间",{"2":{"55":1}}],["索引列的基数越大",{"2":{"55":1}}],["索引",{"2":{"54":1,"59":2}}],["索引的效率要比",{"2":{"59":1}}],["索引的查询效率要远高于",{"2":{"59":1}}],["索引的检索可以一次定位",{"2":{"59":1}}],["索引的结构组织要尽量减少查找过程中磁盘i",{"2":{"58":1}}],["索引的",{"0":{"55":1,"56":1}}],["索引的类型",{"0":{"54":1}}],["索引的使用场景",{"0":{"53":1}}],["索引非常有效",{"2":{"53":1}}],["索引实际上也是一张表",{"2":{"52":1}}],["索引有什么坏处",{"0":{"52":1}}],["索引有什么好处",{"0":{"51":1}}],["索引之所以查的快",{"2":{"51":1}}],["索引使用篇",{"0":{"50":1},"1":{"51":1,"52":1,"53":1,"54":1,"55":1,"56":1}}],["说到索引",{"2":{"50":1}}],["说明",{"2":{"30":2}}],["出度d是非常大的数字",{"2":{"58":1}}],["出队元素",{"2":{"45":1}}],["出队队首元素",{"2":{"45":1}}],["出栈栈顶结点",{"2":{"42":1,"43":1,"44":1}}],["入队当前结点",{"2":{"45":1}}],["入栈当前结点到普通栈",{"2":{"44":1}}],["入栈当前结点到中间栈",{"2":{"44":1}}],["入栈当前结点",{"2":{"43":1}}],["队列",{"2":{"45":1}}],["采用队列",{"2":{"45":1}}],["采用",{"2":{"45":1}}],["实际情况中每个节点可能不能填充满",{"2":{"58":1}}],["实际是斜切向运动",{"2":{"58":1}}],["实际数据库中数据都是存储到外部存储器的",{"2":{"58":1}}],["实际场景下",{"2":{"53":1}}],["实际运行效果如下",{"2":{"30":1}}],["实现思路",{"2":{"45":1}}],["置当前结点的右孩子为当前节点",{"2":{"42":1,"43":1,"44":2}}],["置当前结点的左孩子为当前节点",{"2":{"42":1,"43":1}}],["判断当前队列是否为空",{"2":{"45":1}}],["判断当前结点是否为空",{"2":{"42":1,"43":1,"44":1,"45":1}}],["判断二叉树结点是否为空",{"2":{"42":1,"43":1,"44":1}}],["步骤8",{"2":{"44":2}}],["步骤6",{"2":{"42":1,"44":1}}],["步骤5",{"2":{"42":1,"44":1}}],["步骤4",{"2":{"42":1,"44":2}}],["步骤3",{"2":{"42":1,"44":1}}],["步骤2",{"2":{"42":1,"44":1}}],["步骤1",{"2":{"42":1,"44":1}}],["||",{"2":{"42":1,"43":1,"44":1}}],["循环结束",{"2":{"42":1,"43":1,"44":1}}],["栈空时",{"2":{"42":1,"43":1,"44":1}}],["栈实现",{"2":{"42":2,"43":2,"44":2}}],["显示根结点",{"2":{"42":1,"43":1,"44":1}}],["显著",{"2":{"37":1}}],["访问根节点",{"2":{"42":1,"43":1,"44":1}}],["方式",{"2":{"42":2,"43":2,"44":2,"45":1}}],["方法有如下",{"2":{"30":1}}],["内容",{"2":{"42":1}}],["内存与磁盘以页为单位交换数据",{"2":{"58":1}}],["内存",{"2":{"37":1}}],["简单地说",{"2":{"59":1}}],["简单来说",{"2":{"35":1}}],["简介",{"2":{"42":1,"43":1,"44":1,"45":1}}],["下面我们不妨再来个推算",{"2":{"58":1}}],["下面我们将结合计算机组成原理相关知识讨论b",{"2":{"58":1}}],["下面会详细说明",{"2":{"41":1}}],["下图中采用矩阵的第一和第二列属性得到很好的展示效果",{"2":{"30":1}}],["递归实现",{"2":{"42":1,"43":1,"44":1}}],["递归",{"2":{"41":1,"42":1,"43":1,"44":1}}],["广度优先遍历",{"2":{"40":1}}],["后序遍历",{"0":{"44":1},"2":{"40":1}}],["后的值",{"2":{"30":1}}],["深度优先遍历",{"2":{"40":1,"42":1}}],["遍历右子树",{"2":{"42":1,"43":1,"44":1}}],["遍历左子树",{"2":{"42":1,"43":1,"44":1}}],["遍历的实现方式分为",{"2":{"41":1}}],["遍历实现",{"0":{"41":1},"1":{"42":1}}],["遍历方式总结",{"0":{"46":1}}],["遍历方式",{"0":{"40":1}}],["遍历树的时间就会大大增加",{"2":{"37":1}}],["获得",{"2":{"39":3}}],["获得文件中的数据行的行数",{"2":{"30":1}}],["右孩子",{"2":{"39":2}}],["设置二叉树的右子树",{"2":{"39":1}}],["设置二叉树的左子树",{"2":{"39":1}}],["设置二叉树的结点数据",{"2":{"39":1}}],["设置结点结构",{"2":{"39":1}}],["设置测试的样本数量",{"2":{"30":1}}],["设置测试数据的的一个比例",{"2":{"30":1}}],["且",{"2":{"39":1}}],["按照主键的顺序插入是最快的方式",{"2":{"58":1}}],["按照某种次序访问二叉树中的所有结点",{"2":{"39":1}}],["按照距离递增排序",{"2":{"25":1}}],["二级索引访问需要两次索引查找",{"2":{"58":1}}],["二叉树",{"2":{"58":1}}],["二叉树的右子树",{"2":{"39":1}}],["二叉树的左子树",{"2":{"39":1}}],["二叉树的结点数据",{"2":{"39":1}}],["二叉树的遍历方式包括",{"2":{"40":1}}],["二叉树的遍历",{"0":{"38":1},"1":{"39":1,"40":1,"41":1,"42":1,"43":1,"44":1,"45":1,"46":1}}],["二",{"0":{"57":1},"1":{"58":1,"59":1},"2":{"58":1}}],["二项分布的特例",{"2":{"15":1}}],["请标注信息来源于",{"2":{"37":1}}],["请看这里",{"2":{"36":1}}],["欢迎转载学习",{"2":{"37":1}}],["版权声明",{"2":{"37":1}}],["小瑶",{"2":{"37":1}}],["小结",{"0":{"34":1},"1":{"35":1,"36":1,"37":1}}],["羊三",{"2":{"37":1}}],["作为索引结构",{"2":{"58":1}}],["作者",{"2":{"37":1}}],["作用",{"2":{"37":1}}],["变大",{"2":{"37":1}}],["建议使用整型",{"2":{"58":1}}],["建议的数值是",{"2":{"37":1}}],["建立和使用索引的代价随着增长",{"2":{"53":1}}],["建树时间也就快点",{"2":{"37":1}}],["建树时间",{"2":{"37":1}}],["太小了",{"2":{"37":1}}],["太大太小都不太好",{"2":{"36":1,"37":1}}],["趋向于1",{"2":{"37":1}}],["趋向于",{"2":{"37":1}}],["有可能变成不连续的了",{"2":{"59":1}}],["有一种情况可以无需二次查找",{"2":{"58":1}}],["有",{"2":{"37":1}}],["有n种可能性",{"2":{"15":1}}],["含有algorithm=",{"2":{"37":1}}],["比别人的方法相比有什么优势",{"2":{"63":1}}],["比较大的时候",{"2":{"37":1}}],["比较好",{"2":{"37":1}}],["比如一个样本的label和预测概率分布",{"2":{"19":1,"20":1}}],["比如",{"2":{"16":2,"37":3,"58":1}}],["比如投掷硬币只有两种可能",{"2":{"15":1}}],["比如按下电脑开关的三种可能性",{"2":{"15":1}}],["没有任何约束",{"2":{"54":1}}],["没有ball",{"2":{"37":1}}],["没有建树的过程",{"2":{"37":1}}],["较小本征维数且更稀疏的数据集的查询时间更快",{"2":{"37":1}}],["仍然是",{"2":{"37":1}}],["它的结构",{"2":{"37":1}}],["它的功能是把已经存在的commit进行挑选",{"2":{"9":1}}],["矩阵中使用的概念不同",{"2":{"37":1}}],["稀疏",{"2":{"37":2}}],["稀疏度指的是数据填充参数空间的程度",{"2":{"37":1}}],["稀疏度",{"2":{"37":1}}],["本征维数",{"2":{"37":1}}],["本例没有完成此步骤",{"2":{"33":2}}],["更新主键的代价很高",{"2":{"58":1}}],["更少的查找次数",{"2":{"58":1}}],["更常用的是",{"2":{"53":1}}],["更有优势",{"2":{"37":1}}],["更多细节可以参看",{"2":{"36":1}}],["更多细节请参考",{"2":{"30":1}}],["当存储的数据量很大时同样会导致",{"2":{"58":1}}],["当程序要读取的数据不在主存中时",{"2":{"58":1}}],["当一个数据被用到时",{"2":{"58":1}}],["当需要从磁盘读取数据时",{"2":{"58":1}}],["当系统需要读取主存时",{"2":{"58":1}}],["当数据集比较小的时候",{"2":{"37":1}}],["当维度比较小的时候",{"2":{"37":1}}],["当然了",{"2":{"59":1}}],["当然有更快的实现方式",{"2":{"37":1}}],["当然",{"2":{"9":1,"58":1}}],["甚至是高纬度的数据中",{"2":{"37":1}}],["久一点",{"2":{"37":1}}],["虽然",{"2":{"59":1}}],["虽然innodb也使用b+tree作为索引结构",{"2":{"58":1}}],["虽然建树时间会比",{"2":{"37":1}}],["虽然可以大致描述",{"2":{"16":1}}],["处于相同的数量级",{"2":{"37":1}}],["跟",{"2":{"37":1}}],["感兴趣的可以阅读这个链接",{"2":{"37":1}}],["总消耗",{"2":{"37":1}}],["影响算法因素",{"2":{"37":1}}],["适用范围",{"2":{"37":1}}],["适用数据范围",{"2":{"26":1}}],["高很多",{"2":{"59":1}}],["高",{"2":{"37":1}}],["时间和空间复杂度",{"2":{"37":1}}],["树结构的算法都有建树和查询两个过程",{"2":{"37":1}}],["线性扫描",{"2":{"37":1}}],["线性函数转换",{"2":{"30":1}}],["暴力计算",{"2":{"37":1}}],["中大概存储",{"2":{"58":1}}],["中的一个节点",{"2":{"58":1}}],["中序遍历",{"0":{"43":1},"2":{"40":1}}],["中模型的一些额外干货",{"2":{"37":1}}],["中",{"2":{"36":1,"58":1}}],["中冲突",{"2":{"11":1}}],["地理空间中的一些距离公式",{"2":{"36":1}}],["也无法从",{"2":{"59":1}}],["也就是说查找某一键值的行记录时最多只需要",{"2":{"58":1}}],["也就是说一个深度为",{"2":{"58":1}}],["也就是说一个页",{"2":{"58":1}}],["也就是默认值",{"2":{"37":1}}],["也是不可以使用索引的",{"2":{"56":1}}],["也称",{"2":{"42":1}}],["也可以是",{"2":{"36":1}}],["也能完美的描述样本",{"2":{"16":1}}],["曼哈顿距离",{"2":{"36":1}}],["欧式距离",{"2":{"36":1}}],["使得一次",{"2":{"58":1}}],["使得每个结点被访问1次",{"2":{"39":1}}],["使预测发生错误",{"2":{"36":1}}],["使用什么方式解决",{"2":{"63":1}}],["使用一两句话描述项目的主要功能",{"2":{"63":1}}],["使用一系列的超球体来平分训练数据集",{"2":{"37":1}}],["使用到的技术",{"2":{"63":1}}],["使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度",{"2":{"51":1}}],["使用二叉树根据数据维度来平分参数空间",{"2":{"37":1}}],["使用分类决策来选出对应的标签来作为该查询点的标签",{"2":{"35":1}}],["使用海伦提供的部分数据作为测试样本",{"2":{"30":2}}],["使用算法",{"2":{"26":1,"30":2,"33":2}}],["使用",{"0":{"56":1},"2":{"25":1,"30":4,"37":1}}],["使用git",{"2":{"11":1}}],["使用后面要提到的rebase",{"2":{"10":1}}],["使用check",{"2":{"9":1}}],["容易发生过拟合",{"2":{"36":1}}],["换句话说",{"2":{"36":1,"58":2}}],["换算回初始值",{"2":{"30":1}}],["会浪费多次表数据的访问",{"2":{"59":1}}],["会触发一个缺页异常",{"2":{"58":1}}],["会放弃使用索引",{"2":{"56":1}}],["会增大",{"2":{"36":1}}],["会减小",{"2":{"36":1}}],["但具体实现方式却与myisam截然不同",{"2":{"58":1}}],["但具有唯一性约束",{"2":{"54":1}}],["但它也有以下几个限制",{"2":{"58":1}}],["但缺点是学习的近似误差会增大",{"2":{"36":1}}],["但缺点是",{"2":{"36":1}}],["但是辅助索引搜索需要检索两遍索引",{"2":{"58":1}}],["但是查询字段只有主键",{"2":{"58":1}}],["但是文件系统及数据库系统普遍采用",{"2":{"58":1}}],["但是文件系统及数据库系统普遍采用b",{"2":{"58":1}}],["但是可以沿磁盘半径方向运动",{"2":{"58":1}}],["但是对于",{"2":{"37":1}}],["但是从这个意义上来讲",{"2":{"37":1}}],["但是在高结构的数据",{"2":{"37":1}}],["但是由于kl散度中的前一部分",{"2":{"17":1}}],["但是信息量不足",{"2":{"16":1}}],["但是",{"2":{"10":1,"59":1}}],["值相关联",{"2":{"59":1}}],["值和所对应的行指针信息存放于一个",{"2":{"59":1}}],["值数量",{"2":{"58":1}}],["值信息",{"2":{"58":1}}],["值的时候是组合索引键合并后再一起计算",{"2":{"59":1}}],["值的大小关系",{"2":{"59":1}}],["值的增大就意味着整体的模型变得简单",{"2":{"36":1}}],["值的减小就意味着整体模型变得复杂",{"2":{"36":1}}],["值",{"2":{"36":2,"58":2,"59":5}}],["估计误差小",{"2":{"36":1}}],["估计误差大",{"2":{"36":1}}],["三要素",{"0":{"36":1}}],["相邻的节点也能够被预先载入",{"2":{"58":1}}],["相关",{"2":{"58":1}}],["相对于内存存取",{"2":{"58":1}}],["相对于主存",{"2":{"58":1}}],["相对熵",{"0":{"16":1}}],["相反",{"2":{"37":1}}],["相似同源产物",{"2":{"37":1}}],["相似的",{"2":{"36":1}}],["相近的k个最邻点",{"2":{"35":1}}],["与红黑树的比较",{"2":{"58":1}}],["与主存不同",{"2":{"58":1}}],["与普通索引类似",{"2":{"54":1}}],["与每个训练数据点的距离",{"2":{"35":1}}],["与该数据点的距离",{"2":{"30":1}}],["基于非主键索引查询",{"2":{"58":1}}],["基于电影中的亲吻",{"2":{"25":1}}],["基本原理",{"0":{"35":1}}],["非单调的主键会造成在插入新记录时数据文件为了维持b+tree的特性而频繁的分裂调整",{"2":{"58":1}}],["非聚簇索引就是指b+tree的叶子节点上的data",{"2":{"58":1}}],["非聚簇",{"2":{"58":1}}],["非递归",{"2":{"42":1,"43":1,"44":1,"45":1}}],["非递归实现",{"2":{"42":1,"43":1,"44":1,"45":1}}],["非递归方式",{"2":{"41":1}}],["非泛化学习的监督学习模型",{"2":{"34":1}}],["非监督学习",{"2":{"34":1}}],["监督学习",{"2":{"34":1}}],["定义",{"0":{"39":1},"2":{"34":1}}],["定义熵为",{"2":{"15":1}}],["导入测试数据",{"2":{"33":1}}],["导入训练数据",{"2":{"30":1,"33":1}}],[">",{"2":{"44":1}}],[">0",{"2":{"42":1,"43":1,"44":2}}],[">1",{"2":{"33":1}}],[">>>",{"2":{"33":2}}],["函数",{"2":{"33":1}}],["javascript",{"2":{"64":1}}],["java",{"2":{"64":1}}],["j",{"2":{"33":2}}],["jsexport",{"2":{"66":1}}],["js",{"2":{"9":1}}],["美国的邮件分拣系统就是一个实际运行的类似系统",{"2":{"33":2}}],["若该字段正好需要排序",{"2":{"51":1}}],["若出队元素有右孩子",{"2":{"45":1}}],["若出队元素有左孩子",{"2":{"45":1}}],["若为空则跳出循环",{"2":{"45":1}}],["若为空",{"2":{"42":1,"43":1,"44":1}}],["若不为空",{"2":{"42":1,"43":1,"44":1}}],["若是",{"2":{"42":1,"43":1,"44":1,"45":1}}],["若你感兴趣可以构建完整的应用程序",{"2":{"33":2}}],["若要取消rebase",{"2":{"8":1}}],["区别在于测试样本是已经完成分类的数据",{"2":{"33":1}}],["区间的值",{"2":{"30":1}}],["确保它符合要求",{"2":{"33":2}}],["命令行中输入下列命令测试",{"2":{"33":1}}],["命令提示符中检查数据",{"2":{"33":2}}],["命令如下",{"2":{"9":1}}],["编写函数使用提供的部分数据集作为测试样本",{"2":{"33":2}}],["编写函数",{"2":{"33":2}}],["像素的黑白图像",{"2":{"32":1}}],["像素",{"2":{"32":1}}],["宽高是",{"2":{"32":1}}],["到这里终于可以分析b+tree索引的性能了",{"2":{"58":1}}],["到",{"2":{"32":1}}],["构造一个能识别数字",{"2":{"32":1}}],["手写数字识别系统",{"0":{"31":1},"1":{"32":1,"33":1}}],["约会网站预测函数",{"2":{"30":1}}],["即数据节点",{"2":{"58":1}}],["即一个页",{"2":{"58":1}}],["即使只需要一个字节",{"2":{"58":1}}],["即确定要读的数据在哪个磁道",{"2":{"58":1}}],["即从正上方向下看",{"2":{"58":1}}],["即测试数据的数量",{"2":{"37":1}}],["即矩阵的第一维",{"2":{"30":1}}],["即如果用",{"2":{"16":1}}],["错误数",{"2":{"30":1}}],["度量公式为欧氏距离",{"2":{"30":1}}],["选取这k个中最多的分类类别",{"2":{"30":2}}],["选取前k个最短距离",{"2":{"30":2}}],["生成与最小值之差组成的矩阵",{"2":{"30":1}}],["生成对应的空矩阵",{"2":{"30":1}}],["极差",{"2":{"30":1}}],["极具魅力的人",{"2":{"29":1}}],["范围",{"2":{"30":1}}],["该模型假设在所有维度中方差相同",{"2":{"37":1}}],["该函数可以自动将数字特征值转化为0到1的区间",{"2":{"30":1}}],["该命令会自动提交",{"2":{"9":1}}],["并得到相应的结果",{"2":{"59":1}}],["并不能保证和hash运算前完全一样",{"2":{"59":1}}],["并不是数据本身",{"2":{"58":1}}],["并且可以利用预读特性",{"2":{"58":1}}],["并且只需要很短的旋转时间",{"2":{"58":1}}],["并且只能对英文进行全文检索",{"2":{"54":1}}],["并将其入栈",{"2":{"42":1}}],["并完成数字识别",{"2":{"33":2}}],["并没有用到",{"2":{"30":1}}],["并作为其分类的",{"2":{"24":1}}],["式",{"2":{"30":1}}],["反余切函数转换",{"2":{"30":1}}],["you",{"2":{"30":2}}],["year",{"2":{"30":4}}],["y",{"2":{"30":1}}],["y分别为转换前",{"2":{"30":1}}],["y=arctan",{"2":{"30":1}}],["y=log10",{"2":{"30":1}}],["y=",{"2":{"30":1}}],["表中",{"2":{"59":1}}],["表数据文件本身就是按b+tree组织的一个索引结构",{"2":{"58":1}}],["表",{"2":{"58":2}}],["表的数据发生了变化",{"2":{"52":1}}],["表达式如下",{"2":{"30":3}}],["表示数据的行数",{"2":{"30":1}}],["表示p分布和q分布越接近",{"2":{"16":1}}],["表示当前样本属于第一类",{"2":{"16":1}}],["限制在你需要的一定范围内",{"2":{"30":1}}],["消除特征之间量级不同导致的影响",{"2":{"30":2}}],["+tree作为索引的理论基础",{"2":{"58":1}}],["+tree作为索引结构",{"2":{"58":1}}],["+1之间是统计的坐标分布",{"2":{"30":1}}],["+",{"2":{"30":3,"37":1}}],["+=",{"2":{"30":2,"33":1}}],["$$",{"2":{"30":2}}],["样本3和样本4的距离",{"2":{"30":1}}],["样本分类",{"2":{"30":1}}],["5",{"0":{"42":1,"43":1,"44":1,"45":1,"46":1},"2":{"30":3,"43":1,"45":1,"59":2}}],["zookeeper",{"2":{"64":1}}],["zhihu",{"2":{"30":1,"36":1}}],["zeros",{"2":{"30":3,"33":2}}],["warning",{"2":{"67":6}}],["where",{"2":{"55":1,"56":6}}],["while",{"2":{"42":1,"43":1,"44":2,"45":1}}],["will",{"2":{"30":2}}],["with",{"2":{"30":1,"33":1,"66":1}}],["wise",{"2":{"30":1}}],["www",{"2":{"30":1,"36":1}}],["woman",{"2":{"25":1}}],["works",{"2":{"0":1}}],["归一化公式",{"2":{"30":1}}],["归一化后的数据集",{"2":{"30":1}}],["归一化在",{"2":{"30":1}}],["归一化在0",{"2":{"30":1}}],["归一化的具体作用是归纳统一样本的统计分布性",{"2":{"30":1}}],["归一化就是要把你需要处理的数据经过处理后",{"2":{"30":1}}],["归一化定义",{"2":{"30":1}}],["归一化特征值",{"2":{"30":2}}],["归一化是一个让权重变为统一的过程",{"2":{"30":1}}],["归一化数据",{"2":{"30":2}}],["清晰地标识了三个不同的样本分类区域",{"2":{"30":1}}],["返回步骤1",{"2":{"42":2,"43":2,"44":2}}],["返回该类别来作为目标数据点的预测值",{"2":{"30":1}}],["返回数据矩阵returnmat和对应的类别classlabelvector",{"2":{"30":1}}],["返回已移除字符串头尾指定字符所生成的新字符串",{"2":{"30":1}}],["标签数据",{"2":{"30":1}}],["切割字符串",{"2":{"30":1}}],["以及like",{"2":{"59":1}}],["以10为底的对数函数转换",{"2":{"30":1}}],["以",{"2":{"30":1}}],["各个磁盘必须同步转动",{"2":{"58":1}}],["各个位置上全是",{"2":{"30":1}}],["各个类别的概率之和为1",{"2":{"19":1}}],["例如知道了innodb的索引实现后",{"2":{"58":1}}],["例如移除噪音特征的影响",{"2":{"37":1}}],["例如",{"2":{"30":1,"58":3}}],["例子",{"2":{"9":1}}],["数字",{"2":{"33":1}}],["数据较大时将会导致每个节点",{"2":{"58":1}}],["数据库索引原理及优化",{"2":{"59":1}}],["数据库系统将索引的一个节点的大小设置为页的大小",{"2":{"58":1}}],["数据库系统的设计者巧妙利用了磁盘预读原理",{"2":{"58":1}}],["数据库中使用最为频繁的索引类型",{"2":{"58":1}}],["数据的",{"2":{"37":1}}],["数据维度",{"2":{"37":1}}],["数据集样本数量",{"2":{"37":1}}],["数据集",{"2":{"30":1}}],["数据矩阵可能没有零项",{"2":{"37":1}}],["数据矩阵",{"2":{"30":1}}],["数据文件路径",{"2":{"30":1}}],["数值型和标称型",{"2":{"26":1}}],["的出度一般都非常大",{"2":{"58":1}}],["的高度一般都在",{"2":{"58":1}}],["的高度",{"2":{"58":1}}],["的深度较大",{"2":{"58":1}}],["的数量很小",{"2":{"58":1}}],["的整倍数",{"2":{"58":1}}],["的影响",{"2":{"37":1}}],["的模组",{"2":{"37":1}}],["的查询时间基本不受影响",{"2":{"37":1}}],["的查询时间不受影响",{"2":{"37":1}}],["的改善由于通过坐标轴来平分参数空间的自身特性",{"2":{"37":1}}],["的",{"2":{"37":1,"58":3}}],["的估计误差",{"2":{"36":1}}],["的近似误差",{"2":{"36":1}}],["的基于",{"2":{"32":1}}],["的解析程序",{"2":{"30":1}}],["的差异",{"2":{"16":1}}],["将一个节点的大小设为等于一个页",{"2":{"58":1}}],["将多个列组合在一起创建索引",{"2":{"54":1}}],["将会趋向于",{"2":{"37":1}}],["将",{"2":{"33":1,"59":1}}],["将图像文本数据转换为向量",{"2":{"33":1}}],["将图像文本数据转换为分类器使用的向量",{"2":{"33":1}}],["将图像格式转换为分类器使用的向量格式",{"2":{"33":1}}],["将距离排序",{"2":{"30":2}}],["将最小值之差除以范围组成矩阵",{"2":{"30":1}}],["将输入值换算为",{"2":{"30":1}}],["将文本记录转换为",{"2":{"30":1}}],["将新数据的每个特征与样本集中数据对应的特征进行比较",{"2":{"26":1}}],["9~2025",{"2":{"61":1}}],["9",{"2":{"30":1,"32":1,"62":1}}],["953952\\t3",{"2":{"30":1}}],["9b47dd这两个的结果可能会不一样",{"2":{"9":1}}],["9b47dd",{"2":{"9":2}}],["文本文件数据格式如下",{"2":{"30":1}}],["玩视频游戏所耗时间百分比",{"2":{"30":2}}],["产生简单的命令行程序",{"2":{"30":2}}],["测试范围",{"2":{"30":1}}],["测试样本与非测试样本的",{"2":{"33":1}}],["测试样本是已经完成分类的数据",{"2":{"30":1}}],["测试样本和非测试样本的区别在于",{"2":{"30":1}}],["测试算法",{"2":{"26":1,"30":2,"33":2}}],["画二维散点图",{"2":{"30":2}}],["周末与极具魅力的人约会",{"2":{"29":1}}],["她希望",{"2":{"29":1}}],["她发现曾交往过三种类型的人",{"2":{"29":1}}],["魅力一般的人",{"2":{"29":1}}],["海伦使用约会网站寻找约会对象",{"2":{"29":1}}],["项目",{"2":{"63":1}}],["项目经历",{"0":{"63":1}}],["项目概述",{"0":{"29":1,"32":1}}],["项目案例2",{"0":{"31":1},"1":{"32":1,"33":1}}],["项目案例1",{"0":{"28":1},"1":{"29":1,"30":1}}],["项目案例",{"0":{"27":1},"1":{"28":1,"29":1,"30":1,"31":1,"32":1,"33":1}}],["空间复杂度高",{"2":{"26":1}}],["缺点",{"2":{"26":1,"37":1}}],["精度高",{"2":{"26":1}}],["优化器将无法通过索引来确定将要命中的行数",{"2":{"56":1}}],["优化约会网站的配对效果",{"0":{"28":1},"1":{"29":1,"30":1}}],["优点",{"2":{"26":1,"37":1}}],["优秀文章",{"0":{"11":1}}],["计算之后的",{"2":{"59":1}}],["计算机主存一般比较小",{"2":{"58":1}}],["计算机主存",{"2":{"58":1}}],["计算目标的数据点",{"2":{"30":1}}],["计算每种属性的最大值",{"2":{"30":1}}],["计算复杂度高",{"2":{"26":1}}],["计算错误率",{"2":{"26":1}}],["计算新数据与样本数据集中每条数据的距离",{"2":{"26":1}}],["训练数据的样本数量",{"2":{"37":1}}],["训练数据集比例=1",{"2":{"30":1}}],["训练实例也会对预测起作用",{"2":{"36":1}}],["训练实例才会对预测结果起作用",{"2":{"36":1}}],["训练算法",{"2":{"26":1,"30":2,"33":2}}],["训练样本集",{"2":{"26":1}}],["分区键设计不太灵活",{"2":{"53":1}}],["分区表",{"2":{"53":2}}],["分区表很少使用",{"2":{"53":1}}],["分库分表",{"2":{"53":1}}],["分类问题中",{"2":{"36":1}}],["分类决策是哪个标签的质心与测试点最近",{"2":{"37":1}}],["分类决策",{"2":{"36":2}}],["分类器的手写数字识别系统",{"2":{"32":1}}],["分类器针对约会网站的测试代码",{"2":{"30":1}}],["分类时",{"2":{"24":1}}],["分别是数据集中的最小特征值和最大特征值",{"2":{"30":1}}],["分析数据",{"2":{"26":1,"30":2,"33":2}}],["距离",{"2":{"36":1,"58":1}}],["距离度量",{"2":{"30":1,"36":2}}],["距离度量以及分类决策规则是k近邻算法的三个基本要素",{"2":{"24":1}}],["距离计算所需要的数值",{"2":{"26":1}}],["准备数据",{"2":{"26":1,"30":2,"33":2}}],["收集数据",{"2":{"26":1,"30":2,"33":2}}],["开发流程",{"0":{"30":1,"33":1},"2":{"26":1}}],["给定一个训练数据集",{"2":{"26":1}}],["通常在",{"2":{"58":1}}],["通常不超过3",{"2":{"58":1}}],["通常超过100",{"2":{"58":1}}],["通常为通过少数服从多数",{"2":{"36":1}}],["通常为",{"2":{"36":1}}],["通过了",{"2":{"61":1}}],["通过一个行地址和一个列地址可以唯一定位到一个存储单元",{"2":{"58":1}}],["通过距离度量来计算查询点",{"2":{"35":1}}],["通过某种算法",{"2":{"30":1}}],["通过多数表决等方式进行预测",{"2":{"24":1}}],["通俗理解",{"2":{"26":1}}],["求职意向",{"2":{"60":1}}],["求",{"2":{"26":1}}],["取值为",{"2":{"58":1}}],["取值范围",{"2":{"14":1}}],["取前",{"2":{"26":1}}],["从示意图中也能看到",{"2":{"59":1}}],["从上文知道",{"2":{"58":1}}],["从上面的图来看",{"2":{"59":1}}],["从上面的",{"2":{"58":1}}],["从抽象角度看",{"2":{"58":1}}],["从而减低的更新速度",{"2":{"52":1}}],["从根节点出发",{"2":{"39":1}}],["从图像中提取数字",{"2":{"33":1}}],["从图像中提取",{"2":{"33":1}}],["从文件中加载数据",{"2":{"30":1}}],["从小到大",{"2":{"26":1,"30":2}}],["从事过java",{"2":{"22":1,"48":1}}],["输出",{"2":{"45":1}}],["输出中间栈的结点",{"2":{"44":1}}],["输出当前节点",{"2":{"42":1,"43":1}}],["输出为实例的类别",{"2":{"24":1}}],["输入样本数据和结构化的输出结果",{"2":{"26":1}}],["输入没有标签的新数据后",{"2":{"26":1}}],["原则",{"0":{"55":1}}],["原理",{"0":{"26":1}}],["原本应该是使用kl散度的",{"2":{"17":1}}],["决定未知电影的类型",{"2":{"25":1}}],["假定",{"2":{"25":1}}],["假设我们以col1为主键",{"2":{"58":1}}],["假设有一个带有标签的样本数据集",{"2":{"26":1}}],["假设x是一个离散型随机变量",{"2":{"14":1}}],["假设master分支提交的与feat提交的在同一份文件中",{"2":{"7":1}}],["个人信息",{"0":{"60":1}}],["个键值",{"2":{"58":1}}],["个字节",{"2":{"58":1}}],["个邻点",{"2":{"37":1}}],["个实例的多数属于某个类",{"2":{"26":1}}],["个实例",{"2":{"26":1}}],["个数据中出现次数最多的分类标签作为新数据的分类",{"2":{"26":1}}],["个样本数据对应的分类标签",{"2":{"26":1}}],["个距离最近的电影",{"2":{"25":1}}],["个最近邻的训练实例的类别",{"2":{"24":1}}],["打斗出现的次数",{"2":{"25":1}}],["打斗次数更多",{"2":{"25":1}}],["亲吻次数更多",{"2":{"25":1}}],["呢",{"2":{"25":1}}],["爱情片",{"2":{"25":2}}],["动作片",{"2":{"25":2}}],["那么哈希索引明显有绝对优势",{"2":{"59":1}}],["那么将会存在大量记录指针信息存于同一个",{"2":{"59":1}}],["那么在二级索引中就可以查找到",{"2":{"58":1}}],["那么如何区分",{"2":{"25":1}}],["那mysql为何使用b+树呢",{"2":{"58":1}}],["那查询的时候",{"2":{"37":1}}],["那个会先拉取",{"2":{"8":1}}],["电影可以按照题材分类",{"2":{"25":1}}],["电脑爆炸了",{"2":{"15":1}}],["电脑无法开机",{"2":{"15":1}}],["电脑正常开机",{"2":{"15":1}}],["场景",{"0":{"25":1}}],["模型",{"2":{"24":1}}],["模型训练就是为了降低这个所需的",{"2":{"16":1}}],["因为存在所谓的哈希碰撞问题",{"2":{"59":1}}],["因为原先是有序的键值",{"2":{"59":1}}],["因为只需要经过一次算法即可找到相应的键值",{"2":{"59":1}}],["因为经过相应的",{"2":{"59":1}}],["因为innodb数据文件本身是一颗b+tree",{"2":{"58":1}}],["因为innodb的数据文件本身要按主键聚集",{"2":{"58":1}}],["因为所有辅助索引都引用主索引",{"2":{"58":1}}],["因为",{"2":{"58":1}}],["因为将会导致被更新的行移动",{"2":{"58":1}}],["因为是估值",{"2":{"58":1}}],["因为不存在机械操作",{"2":{"58":1}}],["因为无法使用索引",{"2":{"56":1}}],["因为复合索引的基数会更大",{"2":{"55":1}}],["因为测试数据每一次都要与全量的训练数据进行比较",{"2":{"30":1,"33":1}}],["因为我在开发的过程中同步拉取了远程的代码",{"2":{"9":1}}],["因此innodb表数据文件本身就是主索引",{"2":{"58":1}}],["因此在数据库中",{"2":{"58":1}}],["因此可以对",{"2":{"58":1}}],["因此h非常小",{"2":{"58":1}}],["因此对于具有局部性的程序来说",{"2":{"58":1}}],["因此为了提高效率",{"2":{"58":1}}],["因此磁盘i",{"2":{"58":1}}],["因此索引往往以索引文件的形式存储在磁盘上",{"2":{"58":1}}],["因此mysql数据库支持多种索引类型",{"2":{"57":1}}],["因此需要搜索该表的所有行",{"2":{"56":1}}],["因此我们判定未知电影是爱情片",{"2":{"25":1}}],["因此",{"2":{"24":1,"58":4}}],["近似误差和估计误差",{"2":{"36":1}}],["近似误差大",{"2":{"36":1}}],["近似误差小",{"2":{"36":1}}],["近朱者赤近墨者黑",{"2":{"24":1}}],["近邻",{"2":{"24":1}}],["近邻算法判断输入数据分类属于哪个分类",{"2":{"26":1}}],["近邻算法构造程序",{"2":{"25":1}}],["近邻算法实际上利用训练数据集对特征向量空间进行划分",{"2":{"24":1}}],["近邻算法假设给定一个训练数据集",{"2":{"24":1}}],["近邻算法的输入为实例的特征向量",{"2":{"24":1}}],["近邻算法",{"0":{"23":1},"1":{"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":1,"34":1,"35":1,"36":1,"37":1},"2":{"24":1,"26":1,"30":2}}],["nlp算法工程师",{"2":{"60":1}}],["null",{"2":{"42":2,"43":2,"44":2,"56":1}}],["num",{"2":{"56":2}}],["number",{"2":{"33":1,"37":3}}],["numberoflines",{"2":{"30":2}}],["numtestvecs=",{"2":{"30":1}}],["numtestvecs",{"2":{"30":7}}],["numpy",{"2":{"30":1}}],["nn",{"2":{"37":1}}],["ndk",{"2":{"37":1}}],["nd",{"2":{"37":1}}],["n",{"2":{"37":7}}],["new",{"2":{"42":1,"43":1,"44":2}}],["neighbors",{"2":{"35":1,"37":1}}],["nearest",{"2":{"35":1,"37":2}}],["nearestneighbor",{"2":{"24":1}}],["nthe",{"2":{"33":2}}],["node>",{"2":{"42":2,"43":2,"44":4,"45":2}}],["node",{"2":{"42":2,"43":2,"44":2,"45":1}}],["nominal",{"2":{"37":1}}],["no",{"2":{"37":1}}],["none",{"2":{"30":1}}],["normmat",{"2":{"30":6}}],["normdataset",{"2":{"30":6}}],["normal进行了1次提交",{"2":{"9":1}}],["not",{"2":{"25":1,"30":1,"37":1}}],["概述",{"0":{"24":1}}],["概率p",{"2":{"15":1}}],["概率越大",{"2":{"14":1}}],["概率越小",{"2":{"14":1}}],["概率分布函数为",{"2":{"14":1}}],["概率小的事件发生了",{"2":{"14":1}}],["概率大的事件发生了",{"2":{"14":1}}],["key为主键",{"2":{"58":1}}],["key",{"2":{"58":6}}],["key=operator",{"2":{"30":1}}],["k越大",{"2":{"37":1}}],["kn",{"2":{"37":1}}],["knn",{"0":{"24":1,"25":1,"26":1,"27":1,"34":1,"36":1},"1":{"28":1,"29":1,"30":1,"31":1,"32":1,"33":1,"35":1,"36":1,"37":1},"2":{"24":1,"25":1,"26":4,"30":3,"32":1,"33":7,"34":2}}],["kd",{"2":{"37":8}}],["k个最邻点的标签的平均值",{"2":{"36":1}}],["k值大",{"2":{"36":1}}],["k值小的时候",{"2":{"36":1}}],["k值的选择",{"2":{"24":1}}],["k的取值",{"2":{"36":1,"37":1}}],["k=3",{"2":{"25":1}}],["k近邻算法不具有显式的学习过程",{"2":{"24":1}}],["k",{"0":{"23":1},"1":{"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":1,"34":1,"35":1,"36":1,"37":1},"2":{"24":7,"25":2,"26":7,"30":4,"35":1,"36":5,"37":3,"58":1}}],["kl",{"2":{"16":1}}],["kl散度公式拆开",{"2":{"17":1}}],["kl散度值越小",{"2":{"16":1}}],["kl散度的计算公式",{"2":{"16":1}}],["kl散度",{"0":{"16":1}}],["刷算法",{"2":{"22":1,"48":1}}],["看书",{"2":{"22":1,"48":1}}],["透彻理解交叉熵背后的直觉",{"2":{"20":1}}],["参考博客",{"2":{"20":1}}],["同理",{"2":{"59":1}}],["同时喜欢足球和英雄联盟",{"2":{"22":1,"48":1}}],["同样也是一颗b+tree",{"2":{"58":1}}],["同样",{"2":{"20":1}}],["同样的",{"2":{"20":1}}],["同步master",{"0":{"7":1}}],["前面已经知道",{"2":{"59":1}}],["前面说过一般使用磁盘i",{"2":{"58":1}}],["前面说过对于二项分布这种特殊的分布",{"2":{"20":1}}],["前序遍历",{"0":{"42":1},"2":{"40":1,"42":1}}],["前端架构师的",{"2":{"11":1}}],["每次新建节点时",{"2":{"58":1}}],["每个非主键索引的",{"2":{"58":1}}],["每个主键索引的",{"2":{"58":1}}],["每个节点中不仅包含数据的",{"2":{"58":1}}],["每个存储块称为一页",{"2":{"58":1}}],["每个存储单元有唯一的地址",{"2":{"58":1}}],["每个存储单元存储固定大小的数据",{"2":{"58":1}}],["每个扇区是磁盘的最小存储单元",{"2":{"58":1}}],["每个段叫做一个扇区",{"2":{"58":1}}],["每个同心环叫做一个磁道",{"2":{"58":1}}],["每个磁头同一时刻也必须是同轴的",{"2":{"58":1}}],["每个磁头负责存取一个磁盘的内容",{"2":{"58":1}}],["每个类别概率独立分布",{"2":{"20":1}}],["每列的类别数据",{"2":{"30":1}}],["每列的属性数据",{"2":{"30":1}}],["每周消费的冰淇淋公升数",{"2":{"30":2}}],["每年获得的飞行常客里程数",{"2":{"30":2}}],["每一块称为一页",{"2":{"58":1}}],["每一个节点只有两种可能值",{"2":{"20":1}}],["每一张图像样本可以同时有多个类别",{"2":{"20":1}}],["每一张图像样本只能有一个类别",{"2":{"19":1}}],["每一种可能性都有一个概率p",{"2":{"15":1}}],["8b+8b",{"2":{"58":1}}],["805124\\t1",{"2":{"30":1}}],["8",{"2":{"20":1,"30":1,"58":1}}],["多分类的pred是用sigmoid算出来的",{"2":{"20":1}}],["多分类的标签是n",{"2":{"20":1}}],["多分类问题",{"2":{"20":1}}],["hash运算结果的",{"2":{"59":1}}],["hash",{"2":{"59":35}}],["handwritingclasstest",{"2":{"33":1}}],["h明显要深的多",{"2":{"58":1}}],["h",{"2":{"58":5}}],["highlighted",{"2":{"66":2}}],["highlighting",{"0":{"66":1},"2":{"66":2}}],["high",{"2":{"37":1}}],["hwlabels存储0～9对应的index位置",{"2":{"33":1}}],["hwlabels",{"2":{"33":3}}],["horatio",{"2":{"30":3}}],["hot",{"2":{"20":2}}],["https",{"2":{"30":1,"36":1,"37":1}}],["he",{"2":{"25":1}}],["head~2",{"2":{"8":1}}],["单分类的pred是用softmax算出来的",{"2":{"19":1}}],["单分类问题的标签为one",{"2":{"20":1}}],["单分类问题",{"2":{"19":1}}],["60793482",{"2":{"36":1}}],["64",{"2":{"33":1}}],["67",{"2":{"30":2}}],["673904\\t2",{"2":{"30":1}}],["669788\\t0",{"2":{"30":1}}],["6",{"2":{"19":1,"43":2,"44":1,"45":1,"61":2}}],["61",{"2":{"15":1}}],["老鼠",{"2":{"19":1,"20":1}}],["青蛙",{"2":{"19":1,"20":1}}],["猫",{"2":{"19":1,"20":1}}],["机器学习中交叉熵的应用",{"0":{"18":1},"1":{"19":1,"20":1}}],["只是主索引中的key一定得是唯一的",{"2":{"58":1}}],["只是主索引要求key是唯一的",{"2":{"58":1}}],["只需一次哈希算法即可立刻定位到相应的位置",{"2":{"59":1}}],["只需很少的旋转时间",{"2":{"58":1}}],["只需要关注交叉熵就可以了",{"2":{"17":1}}],["只有innodb类型的表才可以使用外键索引",{"2":{"54":1}}],["只有与输入实例较近的",{"2":{"36":1}}],["只被访问1次",{"2":{"39":1}}],["只与真实label有关",{"2":{"17":1}}],["故在优化过程中",{"2":{"17":1}}],["−h",{"2":{"17":1}}],["就没办法再利用索引完成范围查询检索",{"2":{"59":1}}],["就需要先找到该键所在位置",{"2":{"59":1}}],["就很容易明白为什么不建议使用过长的字段作为主键",{"2":{"58":1}}],["就能完全载入一个节点",{"2":{"58":1}}],["就实现了一个node只需一次i",{"2":{"58":1}}],["就选哪个标签",{"2":{"37":1}}],["就相当于用较大的邻域中的训练实例进行预测",{"2":{"36":1}}],["就相当于用较小的邻域中的训练实例进行预测",{"2":{"36":1}}],["就是指主索引文件和数据文件为同一份文件",{"2":{"58":1}}],["就是一个灾难",{"2":{"53":1}}],["就是",{"2":{"30":1}}],["就是生成一个",{"2":{"30":1}}],["就是交叉熵",{"2":{"17":1}}],["就把该输入实例分为这个类",{"2":{"26":1}}],["就可以自动划分电影的题材类型",{"2":{"25":1}}],["就有可能需要处理两次冲突",{"2":{"7":1}}],["400",{"2":{"30":1}}],["40920\\t8",{"2":{"30":1}}],["428964\\t1",{"2":{"30":1}}],["441871\\t0",{"2":{"30":1}}],["4",{"0":{"17":1,"45":1,"46":1},"2":{"30":1,"42":1,"43":3,"44":2,"45":1,"58":1,"59":2,"66":1}}],["此时系统会向磁盘发出读盘信号",{"2":{"58":1}}],["此时q等价于p",{"2":{"16":1}}],["此处考虑的是最蠢的方法",{"2":{"37":1}}],["此步骤不适用于",{"2":{"26":1,"30":2,"33":2}}],["此样本的交叉熵计算过程如下",{"2":{"19":1,"20":1}}],["此外还有一类比较特殊的问题",{"2":{"15":1}}],["直接申请一个页的空间",{"2":{"58":1}}],["直接merge分支是行不通的",{"2":{"9":1}}],["直到找到相应的数据",{"2":{"59":1}}],["直到当前结点为空",{"2":{"42":1,"43":1,"44":1}}],["直到不再需要额外的",{"2":{"16":1}}],["一种是对于主键的范围查找和分页查找",{"2":{"58":1}}],["一个指向根节点",{"2":{"58":1}}],["一个磁盘由大小相同且同轴的圆形盘片组成",{"2":{"58":1}}],["一个batch的loss则是每个sample的交叉熵loss平均值",{"2":{"19":1,"20":1}}],["一旦数据量并发量上来",{"2":{"53":1}}],["一",{"0":{"50":1},"1":{"51":1,"52":1,"53":1,"54":1,"55":1,"56":1},"2":{"58":1}}],["一部分测试一部分作为样本",{"2":{"30":1}}],["一般表的主键类型为",{"2":{"58":1}}],["一般实际应用中",{"2":{"58":1}}],["一般来说",{"2":{"58":1}}],["一般使用全文索引引擎",{"2":{"54":1}}],["一般以索引文件的形式存储在磁盘上",{"2":{"52":1}}],["一般小于等于",{"2":{"26":1}}],["一般用来求目标与预测值之间的差距",{"2":{"12":1}}],["一句话总结",{"2":{"24":1}}],["一文搞懂交叉熵在机器学习中的使用",{"2":{"20":1}}],["一样完美的描述",{"2":{"16":1}}],["才能达到和",{"2":{"16":1}}],["需要将磁头放到这个扇区上方",{"2":{"58":1}}],["需要识别的数字是存储在文本文件中的具有相同的色彩和大小",{"2":{"32":1}}],["需要分类的数据点",{"2":{"30":1}}],["需要额外的一些",{"2":{"16":1}}],["需要根据影响的范围而指定不同的模式",{"2":{"10":1}}],["来连接条件",{"2":{"56":1}}],["来加权",{"2":{"37":1}}],["来选取票数最多的标签",{"2":{"36":1}}],["来选取适合的k值",{"2":{"36":1}}],["来描述样本",{"2":{"16":1}}],["来描述目标问题",{"2":{"16":2}}],["来表示模型所预测的分布",{"2":{"16":1}}],["来表示样本的真实分布",{"2":{"16":1}}],["用非单调的字段作为主键在innodb中不是个好主意",{"2":{"58":1}}],["用b",{"2":{"58":1}}],["用",{"2":{"16":3}}],["用cherry",{"2":{"9":1}}],["得到的信息增量",{"2":{"16":1}}],["q=new",{"2":{"45":1}}],["quot",{"2":{"37":2,"59":6}}],["queue",{"2":{"45":1}}],["query",{"2":{"35":2,"37":1}}],["question",{"2":{"30":1,"36":1}}],["q",{"2":{"16":4,"45":5}}],["和外部存储器",{"2":{"58":1}}],["和brute",{"2":{"37":1}}],["和对应的类别",{"2":{"30":1}}],["和",{"2":{"16":1,"25":2,"30":1,"37":6,"59":1}}],["和normal的第1次提交合并到master分支",{"2":{"9":1}}],["散度用来衡量两个单独的概率分布",{"2":{"16":1}}],["对字符串进行索引",{"2":{"55":1}}],["对中大型表",{"2":{"53":1}}],["对非常小的表",{"2":{"53":1}}],["对应的索引也需要一起变更",{"2":{"52":1}}],["对应于特征空间的点",{"2":{"24":1}}],["对kd",{"2":{"37":1}}],["对查询点标签影响显著",{"2":{"36":1}}],["对数据测试",{"2":{"30":1}}],["对数函数转换",{"2":{"30":1}}],["对约会网站的测试方法",{"2":{"30":1}}],["对异常值不敏感",{"2":{"26":1}}],["对新的输入实例",{"2":{"26":1}}],["对新的实例",{"2":{"24":1}}],["对求得的所有距离进行排序",{"2":{"26":1}}],["对于选择性比较低的索引键",{"2":{"59":1}}],["对于组合索引",{"2":{"59":1}}],["对于innodb",{"2":{"58":1}}],["对于特大型的表",{"2":{"53":1}}],["对于",{"2":{"37":1,"58":2}}],["对于每一个在数据集中的数据点",{"2":{"30":1}}],["对于这类问题",{"2":{"15":1}}],["对于某个事件",{"2":{"15":1}}],["对信息量做加权求和",{"2":{"15":1}}],["其实本质上也是范围查询",{"2":{"59":1}}],["其实就是以每个可能性的概率为权重",{"2":{"15":1}}],["其检索效率非常高",{"2":{"59":1}}],["其主键是不允许更新的",{"2":{"58":1}}],["其附近的数据也通常会马上被使用",{"2":{"58":1}}],["其优点是可以减少学习的估计误差",{"2":{"36":1}}],["其次是保正程序运行时收敛加快",{"2":{"30":1}}],["其中",{"2":{"58":1}}],["其中的",{"2":{"30":1}}],["其中的实例类别已定",{"2":{"24":1}}],["其中和分别表示训练样本集中负荷的最大值和最小值",{"2":{"30":1}}],["其中包含每条数据与所属分类的对应关系",{"2":{"26":1}}],["其他",{"0":{"10":1}}],["32的矩阵",{"2":{"33":1}}],["32000",{"2":{"30":1}}],["32",{"2":{"30":1,"32":2,"33":6}}],["326976\\t0",{"2":{"30":1}}],["3的矩阵",{"2":{"30":1}}],["38344\\t1",{"2":{"30":1}}],["3",{"0":{"16":1,"41":1,"42":1,"43":1,"44":2,"45":1},"1":{"42":1},"2":{"19":1,"30":7,"33":1,"42":1,"43":2,"44":1,"45":1,"58":1,"59":2}}],["30的时候",{"2":{"37":1}}],["30",{"2":{"15":1,"37":1}}],["36",{"2":{"15":1}}],["75136\\t13",{"2":{"30":1}}],["7",{"2":{"15":1,"16":1,"20":1,"43":1,"45":1}}],["事件",{"2":{"15":1}}],["序号",{"2":{"15":1,"30":1}}],["熵的计算可以进行简化",{"2":{"20":1}}],["熵的计算方法可以简化为如下算式",{"2":{"15":1}}],["熵表示所有信息量的期望",{"2":{"15":1}}],["熵",{"0":{"15":1}}],["2~4",{"2":{"58":1}}],["26052\\t1",{"2":{"30":1}}],["2010",{"2":{"62":1}}],["2021",{"2":{"61":1}}],["20000",{"2":{"30":1}}],["20",{"2":{"26":1,"30":1,"37":1,"56":1}}],["2",{"0":{"15":1,"20":1,"40":1,"43":1,"59":1},"2":{"15":1,"16":1,"30":9,"33":5,"42":1,"43":2,"44":1,"45":1,"58":1,"59":2}}],["纵坐标为信息量",{"2":{"14":1}}],["横坐标为概率p",{"2":{"14":1}}],["000",{"2":{"30":3}}],["0",{"2":{"14":1,"15":3,"16":5,"19":5,"20":4,"30":27,"32":1,"33":63}}],["则mysql自动为innodb表生成一个隐含字段作为主键",{"2":{"58":1}}],["则mysql系统会自动选择一个可以唯一标识数据记录的列作为主键",{"2":{"58":1}}],["则取出其data域的值",{"2":{"58":1}}],["则此索引的结构如下图所示",{"2":{"58":1}}],["则上图是一个myisam表的主索引",{"2":{"58":1}}],["则将地址信号放到地址总线上传给主存",{"2":{"58":1}}],["则正好降低了排序的成本",{"2":{"51":1}}],["则入队其右孩子",{"2":{"45":1}}],["则入队其左孩子",{"2":{"45":1}}],["则返回空操作",{"2":{"42":1,"43":1,"44":1,"45":1}}],["则标记为一个错误",{"2":{"30":2,"33":2}}],["则三个最靠近的电影依次是",{"2":{"25":1}}],["则定义事件x=x0的信息量为",{"2":{"14":1}}],["则需要修改冲突文件",{"2":{"9":1}}],["xxxx",{"2":{"62":3,"63":1}}],["xxx",{"2":{"59":1,"62":1}}],["x26",{"2":{"39":3,"42":1,"43":1,"44":1}}],["xmax",{"2":{"30":1}}],["xmin",{"2":{"30":2}}],["xi",{"2":{"15":1}}],["x",{"2":{"14":2,"16":2,"17":1,"30":5}}],["x=x",{"2":{"14":1}}],["x3c",{"2":{"0":8,"39":5,"42":2,"43":2,"44":4,"45":2}}],["越小表示越相似",{"2":{"26":1}}],["越可能发生的事件发生了",{"2":{"14":1}}],["越不可能的事件发生时",{"2":{"14":1}}],["我是这样认为的",{"2":{"30":1}}],["我是一名后端开发工程师",{"2":{"22":1,"48":1}}],["我们一般定义主键为不可更新",{"2":{"58":1}}],["我们一般都会定义一个自增的",{"2":{"58":1}}],["我们下面假设磁盘只有一个盘片和一个磁头",{"2":{"58":1}}],["我们必须要考虑到这两种类型的存储特点",{"2":{"58":1}}],["我们这里只讨论分类问题中的",{"2":{"24":1}}],["我们需要评估label和predicts之间的差距",{"2":{"17":1}}],["我们称之为0",{"2":{"15":1}}],["我们获取到的信息量就越小",{"2":{"14":1}}],["我们获取到的信息量就越大",{"2":{"14":1}}],["我提交",{"2":{"9":1}}],["信息增量",{"2":{"16":3}}],["信息量i",{"2":{"15":1}}],["信息量越小",{"2":{"14":1}}],["信息量越大",{"2":{"14":1}}],["信息量图",{"2":{"14":1}}],["信息量大",{"2":{"14":1}}],["信息量小",{"2":{"14":1}}],["信息量",{"0":{"14":1}}],["信息论",{"0":{"13":1},"1":{"14":1,"15":1,"16":1,"17":1}}],["1~2010",{"2":{"62":1}}],["1~3",{"2":{"58":1}}],["1994",{"2":{"60":1}}],["19951858",{"2":{"30":1}}],["16kb",{"2":{"58":2}}],["1次i",{"2":{"58":1}}],["13",{"2":{"33":1}}],["134",{"2":{"30":1}}],["134296\\t1",{"2":{"30":1}}],["100",{"2":{"61":1}}],["10000",{"2":{"30":1}}],["10亿",{"2":{"58":1}}],["10^3",{"2":{"58":2}}],["1024的矩阵",{"2":{"33":1}}],["1024",{"2":{"33":2}}],["10",{"2":{"30":1,"56":1,"58":1}}],["1之间是统计的概率分布",{"2":{"30":1}}],["12",{"2":{"30":1}}],["15",{"2":{"30":2}}],["153469\\t1",{"2":{"30":1}}],["111",{"2":{"30":1}}],["147394\\t0",{"2":{"30":1}}],["14488\\t7",{"2":{"30":1}}],["1分布问题",{"2":{"15":1}}],["1",{"0":{"14":1,"19":1,"38":1,"39":2,"40":1,"41":1,"42":1,"58":1},"1":{"39":1,"40":1,"41":1,"42":2,"43":1,"44":1,"45":1,"46":1},"2":{"14":1,"15":1,"16":2,"19":2,"20":3,"30":23,"33":14,"42":1,"43":2,"44":1,"45":1,"59":2}}],["1值是9b47dd",{"2":{"9":1}}],["是因为先将数据排好序",{"2":{"51":1}}],["是一个很好的base",{"2":{"37":1}}],["是一个简单的无显示学习过程",{"2":{"34":1}}],["是指数据所在的流形的维数",{"2":{"37":1}}],["是什么",{"2":{"34":1}}],["是固定不变的",{"2":{"17":1}}],["是深度学习中常用的一个概念",{"2":{"12":1}}],["是需要合并的commit的前一个commit节点的id",{"2":{"8":1}}],["export",{"2":{"66":1}}],["extensions",{"2":{"65":1,"68":1}}],["extension",{"0":{"65":1},"1":{"66":1,"67":1,"68":1}}],["examples",{"0":{"0":1,"65":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1,"66":1,"67":1,"68":1}}],["else",{"2":{"42":1,"43":1,"44":1}}],["element",{"2":{"30":1}}],["euclidean",{"2":{"36":1}}],["estimation",{"2":{"36":1}}],["earned",{"2":{"30":2}}],["errors",{"2":{"33":1}}],["error",{"2":{"30":1,"33":1,"36":2}}],["errorcount",{"2":{"30":4,"33":4}}],["entropy",{"2":{"12":1}}],["交叉熵的计算也可以简化",{"2":{"20":1}}],["交叉熵在这里是单独对每一个节点进行计算",{"2":{"20":1}}],["交叉熵在多分类问题中的使用",{"0":{"20":1}}],["交叉熵在单分类问题上基本是标配的loss",{"2":{"19":1}}],["交叉熵在单分类问题中的使用",{"0":{"19":1}}],["交叉熵",{"0":{"12":1,"17":1},"1":{"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1},"2":{"12":1}}],["你有几成火候",{"2":{"11":1}}],["功力",{"2":{"11":1}}],["如硬盘",{"2":{"58":1}}],["如btree索引",{"2":{"57":1}}],["如",{"2":{"56":1}}],["如图",{"2":{"30":2}}],["如何优雅解决git",{"2":{"11":1}}],["如果键值不是唯一的",{"2":{"59":1}}],["如果是范围查询检索",{"2":{"59":1}}],["如果是等值查询",{"2":{"59":1}}],["如果是一般索引的话",{"2":{"58":1}}],["如果创建",{"2":{"59":1}}],["如果不存在这种列",{"2":{"58":1}}],["如果不走分区键",{"2":{"53":1}}],["如果没有显式指定",{"2":{"58":1}}],["如果指定的key存在",{"2":{"58":1}}],["如果我们在col2上建立一个辅助索引",{"2":{"58":1}}],["如果我们的q通过反复训练",{"2":{"16":1}}],["如果需要模糊匹配",{"2":{"56":1}}],["如果此时想要索引",{"2":{"56":1}}],["如果",{"2":{"56":1,"58":1}}],["如果在分区表实施关联",{"2":{"53":1}}],["如果leaf",{"2":{"37":2}}],["如果kd",{"2":{"37":1}}],["如果选择较大的",{"2":{"36":1}}],["如果选择较小的",{"2":{"36":1}}],["如果邻近的实例点恰巧是噪声",{"2":{"36":1}}],["如果预测分类与实际类别不同",{"2":{"30":2,"33":2}}],["如果有冲突",{"2":{"9":1}}],["如果normal第一次提交的sha",{"2":{"9":1}}],["猴子都能懂的git入门",{"2":{"11":1}}],["删除或合并提交",{"2":{"10":1}}],["替换",{"2":{"10":1}}],["您可以改写",{"2":{"10":1}}],["不像b树那样波动幅度大",{"2":{"59":1}}],["不像b",{"2":{"59":1}}],["不需要寻道时间",{"2":{"58":1}}],["不过目前已经有多磁头独立技术",{"2":{"58":1}}],["不会对时间有任何影响",{"2":{"58":1}}],["不可能全部存储在内存中",{"2":{"58":1}}],["不能用于基于范围的过滤",{"2":{"59":1}}],["不能使用范围查询",{"2":{"59":1}}],["不能在前",{"2":{"56":1}}],["不能随便删除已经发布的提交",{"2":{"10":1}}],["不要在",{"2":{"56":1}}],["不允许有空值",{"2":{"54":1}}],["不太可控",{"2":{"53":1}}],["不相似的",{"2":{"36":1}}],["不喜欢的人则直接排除掉",{"2":{"29":1}}],["不喜欢的人",{"2":{"29":1}}],["不包含第1次提交",{"2":{"9":1}}],["在有大量重复键值情况下",{"2":{"59":1}}],["在该索引实现方式中b+tree的叶子节点上的data就是数据本身",{"2":{"58":1}}],["在结构上没有任何区别",{"2":{"58":1}}],["在myisam中",{"2":{"58":1}}],["在master的基础上",{"2":{"9":1}}],["在实际实现b",{"2":{"58":1}}],["在许多操作系统中",{"2":{"58":1}}],["在磁盘的一侧有磁头支架",{"2":{"58":1}}],["在设计索引算法和存储结构时",{"2":{"58":1}}],["在计算机系统中一般包含两种类型的存储",{"2":{"58":1}}],["在数据十分庞大的时候",{"2":{"50":1}}],["在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址",{"2":{"50":1}}],["在n的占比较大的时候",{"2":{"37":1}}],["在参数空间可以是线性或非线性的",{"2":{"37":1}}],["在回归问题中通常为",{"2":{"36":1}}],["在分类和回归中均有应用",{"2":{"34":1}}],["在",{"2":{"33":3,"36":1,"58":1}}],["在统计学中",{"2":{"30":1}}],["在输出层用式",{"2":{"30":1}}],["在训练数据集中找到与该实例最邻近的",{"2":{"26":1}}],["在机器学习中",{"2":{"16":1,"17":1}}],["在rebase指定i选项",{"2":{"10":1}}],["在reset可以遗弃不再使用的提交",{"2":{"10":1}}],["在revert可以取消指定的提交内容",{"2":{"10":1}}],["修改同一个分支最近提交的注解和内容",{"2":{"10":1}}],["修改冲突后的提交不是使用commit命令",{"2":{"8":1}}],["执行5",{"2":{"42":1,"43":1,"44":1}}],["执行3",{"2":{"42":1,"43":1,"44":1}}],["执行遗弃时",{"2":{"10":1}}],["执行完git",{"2":{"9":1}}],["执行如下命令即可把这两个提交合并到master",{"2":{"9":1}}],["这种部分模糊查询",{"2":{"59":1}}],["这个前提是",{"2":{"59":1}}],["这个字段长度为6个字节",{"2":{"58":1}}],["这个索引的key是数据表的主键",{"2":{"58":1}}],["这个过程耗费的时间叫做旋转时间",{"2":{"58":1}}],["这个过程叫做寻道",{"2":{"58":1}}],["这棵树的叶节点data域保存了完整的数据记录",{"2":{"58":1}}],["这也是为什么mysql不使用红黑树作为索引结构的主要原因",{"2":{"58":1}}],["这也是索引失效的原因之一",{"2":{"52":1}}],["这里普及下聚簇索引和非聚簇索引",{"2":{"58":1}}],["这里设表一共有三列",{"2":{"58":1}}],["这里的",{"2":{"58":1}}],["这里可以看出",{"2":{"58":1}}],["这里将其简化成一个二维地址",{"2":{"58":1}}],["这里本文抛却具体差别",{"2":{"58":1}}],["这样的部分模糊查询",{"2":{"59":1}}],["这样的话",{"2":{"58":1}}],["这样要定位某一条记录时就会非常麻烦",{"2":{"59":1}}],["这样可以大大加大每个节点存储的",{"2":{"58":1}}],["这样就保证一个节点物理上也存储在一个页里",{"2":{"58":1}}],["这样每个节点只需要一次i",{"2":{"58":1}}],["这样做的理论依据是计算机科学中著名的局部性原理",{"2":{"58":1}}],["这样会把两个分支的全部提交都合并到master",{"2":{"9":1}}],["这将导致引擎放弃使用索引而进行全表扫描",{"2":{"56":2}}],["这是因为使用索引后可以不用扫描全表来定位某行的数据",{"2":{"50":1}}],["这与",{"2":{"37":1}}],["这更有助于匹配对象的归类",{"2":{"29":1}}],["这",{"2":{"26":1}}],["这时与输入实例较远的",{"2":{"36":1}}],["这时需要通过revert创建要否定的提交",{"2":{"10":1}}],["这时候哈希索引就毫无用武之地了",{"2":{"59":1}}],["这时候",{"2":{"9":1}}],["仅仅是第2次提交",{"2":{"9":1}}],["最适合索引的列是出现在",{"2":{"55":1}}],["最基本的索引",{"2":{"54":1}}],["最快的是",{"2":{"37":1}}],["最小值",{"2":{"30":1}}],["最好是结构化的数据格式",{"2":{"26":1}}],["最好还是不要在开发分支的过程中同步远程master仓库",{"2":{"9":1}}],["最喜欢的语言是java",{"2":{"22":1,"48":1}}],["最后才能访问到页节点这样多次的io访问",{"2":{"59":1}}],["最后对计算出的分类执行后续处理",{"2":{"26":1}}],["最后要说明的是",{"2":{"9":1}}],["最后执行",{"2":{"9":1}}],["最后记得使用git",{"2":{"8":1}}],["别人提交",{"2":{"9":1}}],["games",{"2":{"30":2}}],["getrightnode",{"2":{"39":1,"42":2,"43":2,"44":2,"45":2}}],["getleftnode",{"2":{"39":1,"42":2,"43":2,"44":2,"45":2}}],["getdata",{"2":{"39":1}}],["get",{"2":{"30":1}}],["go",{"2":{"22":1,"48":1}}],["gt",{"2":{"9":2,"37":1,"56":1,"59":1}}],["github",{"2":{"37":1}}],["github地址",{"2":{"37":1}}],["git提交历史的修改删除合并",{"2":{"11":1}}],["git",{"2":{"7":2,"8":3,"9":5,"10":1,"11":1}}],["git常用操作",{"0":{"6":1},"1":{"7":1,"8":1,"9":1,"10":1,"11":1}}],["今天我记得就是我有分支被我弄乱了",{"2":{"9":1}}],["然后介绍自己在项目中的角色",{"2":{"63":1}}],["然后再根据链表往后扫描",{"2":{"59":1}}],["然后用主键到主索引中检索获得记录",{"2":{"58":1}}],["然后以data域的值为地址",{"2":{"58":1}}],["然后异常返回",{"2":{"58":1}}],["然后磁盘旋转将目标扇区旋转到磁头下",{"2":{"58":1}}],["然后将此存储单元数据放到数据总线上",{"2":{"58":1}}],["然后选出与查询点",{"2":{"35":1}}],["然后与文本编辑器打开的文件进行比较",{"2":{"33":1}}],["然后海伦可以输入一些特征数据以判断对方是否为自己喜欢的类型",{"2":{"30":2}}],["然后运行",{"2":{"26":1}}],["然后添加修改文件到暂存区",{"2":{"9":1}}],["然后重新提交",{"2":{"9":1}}],["然后直接git",{"2":{"7":1}}],["而造成整体性能低下",{"2":{"59":1}}],["而且hash值的大小关系并不一定和",{"2":{"59":1}}],["而且所有叶子节点",{"2":{"58":1}}],["而使用自增字段作为主键则是一个很好的选择",{"2":{"58":1}}],["而在innodb中",{"2":{"58":1}}],["而辅助索引的key可以重复",{"2":{"58":1}}],["而",{"2":{"58":1}}],["而反观红黑树这种结构",{"2":{"58":1}}],["而非叶子节点上只存储",{"2":{"58":1}}],["而每一个页的存储空间是有限的",{"2":{"58":1}}],["而各种存储引擎对索引的支持也各不相同",{"2":{"57":1}}],["而是数据存放的地址",{"2":{"58":1}}],["而是每次都会预读",{"2":{"58":2}}],["而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据",{"2":{"50":1}}],["而是执行rebase命令指定",{"2":{"8":1}}],["而这三部电影全是爱情片",{"2":{"25":1}}],["而不是单独计算",{"2":{"59":1}}],["而不是在服务器层实现的",{"2":{"57":1}}],["而不是出现在",{"2":{"55":1}}],["而不是用",{"2":{"16":1}}],["而不是使用vscode的同步代码",{"2":{"8":1}}],["而如果feat分支有两个提交",{"2":{"7":1}}],["强制推送",{"2":{"8":1}}],["合并最近两次提交",{"2":{"8":1}}],["合并多个commit",{"0":{"8":1}}],["leveltravel",{"2":{"45":1}}],["left",{"2":{"39":2}}],["leftnode",{"2":{"39":6}}],["leaf",{"2":{"37":5}}],["len",{"2":{"30":1,"33":2}}],["lt",{"2":{"37":3,"56":1,"59":1}}],["large",{"2":{"30":1}}],["labels",{"2":{"30":3}}],["label",{"2":{"19":1,"20":1,"30":1}}],["load",{"2":{"30":1,"33":1}}],["logdn",{"2":{"58":2}}],["log",{"2":{"8":1,"15":3,"37":2}}],["linkedlist",{"2":{"45":1}}],["linestr",{"2":{"33":2}}],["line",{"2":{"30":4,"37":1,"66":1}}],["like",{"2":{"30":2,"56":1,"66":1}}],["liters",{"2":{"30":2}}],["listdir",{"2":{"33":2}}],["listfromline",{"2":{"30":3}}],["list",{"2":{"5":1,"68":1}}],["o渐进复杂度也为o",{"2":{"58":1}}],["o就可以完全载入",{"2":{"58":1}}],["o次数评价索引结构的优劣",{"2":{"58":1}}],["o效率",{"2":{"58":1}}],["o的时间消耗是巨大的",{"2":{"58":1}}],["o的存取次数",{"2":{"58":1}}],["o存在机械运动耗费",{"2":{"58":1}}],["o存取的消耗要高几个数量级",{"2":{"58":1}}],["o操作",{"2":{"58":1}}],["o操作次数的渐进复杂度",{"2":{"58":1}}],["o消耗",{"2":{"58":1}}],["or",{"2":{"56":2}}],["o",{"2":{"37":10,"58":9}}],["on",{"2":{"37":1}}],["oneline",{"2":{"8":1}}],["open",{"2":{"30":2,"33":1}}],["output",{"2":{"44":4,"66":1,"67":1}}],["outliers",{"2":{"37":1}}],["out",{"2":{"5":1,"68":1}}],["off",{"2":{"33":2}}],["of",{"2":{"0":2,"5":1,"30":4,"33":1,"37":3,"65":1,"68":1}}],["root==null",{"2":{"45":1}}],["root",{"2":{"42":15,"43":15,"44":15,"45":8}}],["right",{"2":{"39":2}}],["rightnode",{"2":{"39":6}}],["rule",{"2":{"36":1}}],["runtime",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1},"2":{"0":1,"5":1}}],["rabbitmq",{"2":{"64":1}}],["ram",{"2":{"58":2}}],["radius",{"2":{"37":1}}],["raw",{"2":{"30":3}}],["rate",{"2":{"30":1,"33":1}}],["range",{"2":{"30":2,"33":4}}],["ranges",{"2":{"30":6}}],["ranges和minvals即最小值与范围",{"2":{"30":1}}],["redis",{"2":{"64":1}}],["regressor",{"2":{"37":1}}],["resultlist",{"2":{"30":2}}],["results",{"0":{"1":1},"1":{"2":1,"3":1,"4":1},"2":{"0":1}}],["reverse=true",{"2":{"30":1}}],["readline",{"2":{"33":1}}],["readlines",{"2":{"30":2}}],["real",{"2":{"30":1,"33":1}}],["really",{"2":{"25":1}}],["returnvect",{"2":{"33":3}}],["returnmat",{"2":{"30":4}}],["return",{"2":{"30":8,"33":1,"39":3,"42":1,"43":1,"44":1,"45":1,"66":2}}],["rebase合并多次commit",{"2":{"11":1}}],["rebase的时候",{"2":{"8":1}}],["rebase",{"2":{"7":2,"8":2}}],["=o",{"2":{"58":2}}],["=null",{"2":{"45":2}}],["==null",{"2":{"42":1,"43":1,"44":1}}],["=2",{"2":{"15":1}}],["=1k",{"2":{"58":1}}],["=1",{"2":{"15":1}}],["=0",{"2":{"15":1}}],["=p",{"2":{"14":1}}],["=",{"2":{"0":1,"30":44,"33":22,"37":1,"39":6,"42":6,"43":6,"44":7,"45":1,"56":4,"58":1,"59":2}}],["features",{"2":{"37":1,"66":1}}],["flier",{"2":{"30":1}}],["float",{"2":{"30":4,"33":1}}],["ffmiles",{"2":{"30":2}}],["figure",{"2":{"30":1}}],["fig",{"2":{"30":2}}],["filer",{"2":{"30":1}}],["file",{"2":{"30":1}}],["filenamestr",{"2":{"33":6}}],["filename",{"2":{"30":4,"33":2}}],["file2matrix",{"2":{"30":3}}],["filestr",{"2":{"33":4}}],["files",{"2":{"0":1}}],["frequent",{"2":{"30":2}}],["fr",{"2":{"30":4,"33":2}}],["frontmatter",{"0":{"4":1},"2":{"0":3,"4":1}}],["from",{"2":{"0":1,"56":1}}],["function",{"2":{"19":1}}],["full",{"2":{"5":1,"68":1}}],["f",{"2":{"8":1,"30":1,"33":1}}],["force了",{"2":{"37":1}}],["force",{"2":{"37":10}}],["for",{"2":{"0":1,"5":1,"30":3,"33":4,"68":1}}],["v",{"0":{"55":1},"2":{"58":1}}],["void",{"2":{"39":3,"42":2,"43":2,"44":2,"45":1}}],["voteilabel",{"2":{"30":3}}],["val",{"2":{"39":4}}],["values",{"2":{"37":2}}],["valid",{"2":{"36":1}}],["validation",{"2":{"36":1}}],["vectorundertest",{"2":{"33":2}}],["vi",{"0":{"56":1},"2":{"58":1}}],["video",{"2":{"30":2}}],["vitepress",{"2":{"0":2,"65":1,"66":1}}],["vue",{"2":{"0":1}}],["msg",{"2":{"66":2}}],["mongodb",{"2":{"58":1}}],["more",{"0":{"5":1,"68":1}}],["myisam可以没有",{"2":{"58":1}}],["myisam索引文件和数据文件是分离的",{"2":{"58":1}}],["myisam索引实现",{"2":{"58":1}}],["myisam的索引方式也叫做",{"2":{"58":1}}],["myisam中索引检索的算法为首先按照b+tree搜索算法搜索索引",{"2":{"58":1}}],["myisam引擎使用b+tree作为索引结构",{"2":{"58":1}}],["myisam",{"2":{"54":1}}],["mycat",{"2":{"53":1}}],["mysql索引背后的数据结果及算法原理",{"2":{"59":1}}],["mysql索引原理",{"2":{"59":1}}],["mysql支持诸多存储引擎",{"2":{"57":1}}],["mysql",{"0":{"55":1,"56":1},"2":{"53":1,"54":1,"56":1,"58":4,"64":1}}],["mysql数据库之索引",{"0":{"49":1}}],["measure",{"2":{"36":1,"37":1}}],["metric",{"2":{"36":2,"37":1}}],["mtest",{"2":{"33":3}}],["miles",{"2":{"30":2}}],["minkowski",{"2":{"36":1}}],["minvals",{"2":{"30":7}}],["minvalue分别为样本的最大值和最小值",{"2":{"30":1}}],["minvalue",{"2":{"30":2}}],["min",{"2":{"30":2}}],["m表示训练样本的数量",{"2":{"30":1}}],["m",{"2":{"30":8,"33":3}}],["markdown",{"0":{"65":1},"1":{"66":1,"67":1,"68":1},"2":{"65":1,"68":1}}],["maxvals",{"2":{"30":2}}],["maxvalue",{"2":{"30":2}}],["max",{"2":{"30":2}}],["matrix",{"2":{"30":1}}],["matplotlib",{"2":{"30":4}}],["man",{"2":{"25":1}}],["master",{"2":{"7":1}}],["main",{"2":{"0":1,"9":1}}],["md```js",{"2":{"66":1}}],["md",{"2":{"0":2,"67":1}}],["id",{"2":{"56":1,"58":6}}],["iv",{"0":{"54":1},"2":{"58":1}}],["iii",{"0":{"53":1},"2":{"58":1}}],["ii",{"0":{"52":1},"2":{"58":1}}],["i+j",{"2":{"33":1}}],["img2vector",{"2":{"33":7}}],["import",{"2":{"0":1,"30":1}}],["ice",{"2":{"30":2}}],["icecream",{"2":{"30":2}}],["if",{"2":{"30":1,"33":1,"42":2,"43":2,"44":2,"45":3}}],["isempty",{"2":{"45":1}}],["is",{"2":{"30":2,"33":3,"56":1,"67":10}}],["i或reset也可以删除提交",{"2":{"10":1}}],["i",{"0":{"51":1},"2":{"8":2,"14":1,"30":6,"33":6,"58":7}}],["info",{"2":{"67":4}}],["innodb的所有辅助索引都引用主键作为data域",{"2":{"58":1}}],["innodb索引实现",{"2":{"58":1}}],["innodb",{"2":{"54":1,"58":3}}],["inorder",{"2":{"43":4}}],["inarr",{"2":{"30":2}}],["input",{"2":{"30":3,"66":1,"67":1}}],["inx",{"2":{"30":2}}],["intrinsic",{"2":{"37":2}}],["int",{"2":{"30":2,"33":3,"58":1}}],["into",{"2":{"25":1}}],["index",{"2":{"30":3}}],["in",{"2":{"0":1,"30":6,"33":4,"59":1,"65":1}}],["iterate",{"2":{"33":1}}],["iteritems",{"2":{"30":1}}],["itemgetter",{"2":{"30":1}}],["it",{"2":{"0":1}}],["custom",{"0":{"67":1}}],["current",{"2":{"0":1}}],["c++",{"2":{"64":1}}],["cet4",{"2":{"61":1}}],["centroid",{"2":{"37":2}}],["cd",{"2":{"58":1}}],["cream",{"2":{"30":2}}],["cross",{"2":{"12":1,"36":1}}],["class",{"2":{"39":1}}],["classnumstr",{"2":{"33":5}}],["classifyperson",{"2":{"30":2}}],["classify0",{"2":{"30":3,"33":1}}],["classifier",{"2":{"30":1,"33":1,"37":2}}],["classifierresult",{"2":{"30":5,"33":3}}],["classcount",{"2":{"30":3}}],["classcount=",{"2":{"30":1}}],["classlabelvector",{"2":{"30":4}}],["chars",{"2":{"30":1}}],["cherry",{"0":{"9":1},"2":{"9":7}}],["check",{"2":{"5":1,"68":1}}],["came",{"2":{"30":1,"33":1}}],["california",{"2":{"25":1}}],["can",{"2":{"0":1}}],["c",{"2":{"15":2}}],["column",{"2":{"56":1}}],["complexity",{"2":{"37":1}}],["computational",{"2":{"37":1}}],["com",{"2":{"30":1,"36":1,"37":1}}],["commithash是commitid",{"2":{"8":1}}],["commithash",{"2":{"8":1}}],["containers",{"0":{"67":1}}],["continuous",{"2":{"37":1}}],["continue后不需要commit了",{"2":{"9":1}}],["continue选项",{"2":{"8":1}}],["continue",{"2":{"7":1,"9":1}}],["consumed",{"2":{"30":2}}],["const",{"2":{"0":1}}],["dangerous",{"2":{"67":2}}],["danger",{"2":{"67":2}}],["datingtestset2",{"2":{"30":2}}],["datingclasstest",{"2":{"30":1}}],["datinglabels",{"2":{"30":8}}],["datingdatamat",{"2":{"30":6}}],["data便会指向对应的主索引",{"2":{"58":1}}],["data域保存数据记录的地址",{"2":{"58":1}}],["datasetsize",{"2":{"30":2}}],["dataset",{"2":{"30":10}}],["data",{"0":{"2":1,"3":1},"2":{"0":3,"30":1,"37":1,"39":4,"58":2,"66":2}}],["dlog",{"2":{"37":2}}],["dn",{"2":{"37":5}}],["dn^2",{"2":{"37":1}}],["doses",{"2":{"30":3}}],["documentation",{"2":{"5":1,"68":1}}],["d",{"2":{"30":2,"33":3,"37":4,"58":1}}],["db",{"2":{"30":1,"33":4}}],["dimensionality",{"2":{"37":2}}],["distance",{"2":{"36":2,"37":1}}],["distances",{"2":{"30":2}}],["diffmat",{"2":{"30":2}}],["divide",{"2":{"30":1}}],["details",{"2":{"67":4}}],["default",{"2":{"66":2}}],["decision",{"2":{"36":1}}],["desc",{"2":{"30":3}}],["demonstrates",{"2":{"0":1,"65":1}}],["dudes",{"2":{"25":1}}],["dd4e49和git",{"2":{"9":1}}],["dd4e49",{"2":{"9":2}}],["syntax",{"0":{"66":1},"2":{"66":1}}],["ssd等",{"2":{"58":1}}],["stack",{"2":{"42":7,"43":7,"44":9}}],["static",{"2":{"39":1,"42":1,"43":1}}],["strip",{"2":{"30":2}}],["str",{"2":{"30":1}}],["size",{"2":{"37":7,"42":1,"43":1,"44":2}}],["site",{"2":{"0":1}}],["samples",{"2":{"37":1}}],["secondary",{"2":{"58":1}}],["select",{"2":{"55":1,"56":1}}],["sensitive",{"2":{"37":1}}],["setrightnode",{"2":{"39":1}}],["setleftnode",{"2":{"39":1}}],["setdata",{"2":{"39":1}}],["set",{"2":{"33":2}}],["setfrom",{"2":{"30":1}}],["setup>",{"2":{"0":1}}],["sklearn",{"0":{"37":1},"2":{"36":1,"37":1}}],["spring",{"2":{"64":1}}],["sphere",{"2":{"53":1}}],["sparsity",{"2":{"37":1}}],["spent",{"2":{"30":2}}],["split",{"2":{"30":1,"33":4}}],["small",{"2":{"30":2}}],["sorted",{"2":{"30":1}}],["sortedclasscount",{"2":{"30":2}}],["sorteddistindicies",{"2":{"30":2}}],["some",{"2":{"0":1,"65":1}}],["sum",{"2":{"30":1}}],["subplot",{"2":{"30":1}}],["sqdistances",{"2":{"30":2}}],["sqdiffmat",{"2":{"30":2}}],["sqrt",{"2":{"30":1}}],["scatter",{"2":{"30":1}}],["script>",{"2":{"0":1}}],["script",{"2":{"0":1}}],["s",{"2":{"25":1,"33":2}}],["shikiji",{"2":{"66":1}}],["sharding",{"2":{"53":1}}],["shape",{"2":{"30":4}}],["shrunken",{"2":{"37":1}}],["show",{"2":{"30":1}}],["sh",{"2":{"9":3}}],["amp",{"2":{"41":1}}],["amend",{"2":{"10":1}}],["ailearning",{"2":{"37":1}}],["algorithm=",{"2":{"37":1}}],["all",{"2":{"30":1}}],["auto",{"2":{"37":2}}],["autonorm",{"2":{"30":3}}],["accuracy",{"2":{"37":1}}],["access",{"2":{"0":1}}],["at",{"2":{"30":1}}],["an",{"2":{"67":2}}],["answer",{"2":{"30":1,"33":1}}],["and",{"2":{"0":2,"37":1}}],["argsort",{"2":{"30":1}}],["array",{"2":{"30":3,"33":2}}],["axis=1",{"2":{"30":1}}],["ax",{"2":{"30":2}}],["assumption",{"2":{"37":1}}],["as",{"2":{"30":1}}],["apachecn",{"2":{"37":2}}],["approximation",{"2":{"36":1}}],["append",{"2":{"30":1,"33":1}}],["apis",{"2":{"0":1,"5":1}}],["api",{"0":{"0":1},"1":{"1":1,"2":1,"3":1,"4":1,"5":1},"2":{"0":1}}],["a",{"2":{"15":2,"42":1,"43":1,"44":1,"67":8}}],["abort可以放弃本次cherry",{"2":{"9":1}}],["abort选项",{"2":{"8":1}}],["additional",{"2":{"66":1}}],["add",{"2":{"7":1,"9":1,"30":1,"45":3}}],["t>",{"2":{"39":5}}],["tree索引高",{"2":{"59":1}}],["tree作为索引结构效率是非常高的",{"2":{"58":1}}],["tree中一次检索最多需要h",{"2":{"58":1}}],["tree还需要使用如下技巧",{"2":{"58":1}}],["tree的定义",{"2":{"58":1}}],["tree的查询时间",{"2":{"37":1}}],["tree分析",{"2":{"58":1}}],["treenode",{"2":{"39":10}}],["tree",{"2":{"37":17,"58":6,"59":4}}],["trainingmat存放的每个位置对应的图片向量",{"2":{"33":1}}],["trainingmat",{"2":{"33":3}}],["training",{"2":{"33":1}}],["trainingdigits",{"2":{"33":2}}],["trainingfilelist",{"2":{"33":3}}],["take",{"2":{"33":2}}],["tip",{"2":{"67":4}}],["time",{"2":{"30":2}}],["tile",{"2":{"30":3}}],["txt",{"2":{"30":2,"33":3}}],["t",{"2":{"30":2,"39":4,"56":1}}],["test",{"2":{"33":1}}],["testfilelist",{"2":{"33":3}}],["testdigits",{"2":{"33":3}}],["testvector",{"2":{"33":3}}],["test第二次提交的值是dd4e49",{"2":{"9":1}}],["test进行了2次提交",{"2":{"9":1}}],["total",{"2":{"30":1,"33":2}}],["to",{"2":{"0":1,"30":1,"37":1}}],["threshold来设置",{"2":{"37":1}}],["through",{"2":{"33":1}}],["theme",{"0":{"2":1},"2":{"0":4,"2":1}}],["the",{"2":{"0":3,"5":2,"30":3,"33":4,"65":1,"68":2}}],["this",{"2":{"0":1,"30":2,"39":6,"65":1,"67":10}}],["block",{"2":{"67":2}}],["box",{"2":{"67":2}}],["both",{"2":{"0":1}}],["built",{"2":{"65":1}}],["bigint",{"2":{"58":1}}],["b+树索引的关键字检索效率比较平均",{"2":{"59":1}}],["b+树索引和哈希索引的明显区别是",{"2":{"59":1}}],["b+",{"2":{"58":3}}],["b+tree差很多",{"2":{"58":1}}],["b+tree更适合外存索引",{"2":{"58":1}}],["b+tree",{"2":{"58":9}}],["b+tree索引的性能分析",{"2":{"58":1}}],["b+tree索引是mysql",{"2":{"58":1}}],["b+tree索引",{"0":{"58":1}}],["ball",{"2":{"37":7}}],["back",{"2":{"30":1,"33":1}}],["brute",{"2":{"37":9}}],["b",{"2":{"15":2,"42":1,"43":1,"44":1,"58":4,"59":3}}],["beautiful",{"2":{"25":1}}],["be",{"2":{"0":1}}],["by",{"2":{"0":1,"65":1,"66":1}}],["used",{"2":{"0":1}}],["usedata",{"2":{"0":3}}],["usage",{"2":{"0":1}}],["powered",{"2":{"66":1}}],["poll",{"2":{"45":1}}],["postorder",{"2":{"44":4}}],["pop",{"2":{"42":1,"43":1,"44":2}}],["points",{"2":{"37":1}}],["point",{"2":{"35":2}}],["public",{"2":{"39":8,"42":2,"43":2,"44":2,"45":1}}],["push",{"2":{"8":1,"42":1,"43":1,"44":2}}],["person",{"2":{"30":2}}],["per",{"2":{"30":4}}],["percentage",{"2":{"30":2}}],["percenttats",{"2":{"30":2}}],["playing",{"2":{"30":2}}],["plt",{"2":{"30":3}}],["pi",{"2":{"30":1}}],["pick后",{"2":{"9":1}}],["pick即可完美的解决问题",{"2":{"9":1}}],["pick就很好的解决了合并提交记录的问题",{"2":{"9":1}}],["pick",{"0":{"9":1},"2":{"9":7}}],["pyplot",{"2":{"30":1}}],["python>>>",{"2":{"30":1,"33":1}}],["pythonimport",{"2":{"30":1}}],["pythondef",{"2":{"30":5,"33":2}}],["python",{"2":{"30":2,"33":3,"64":1}}],["python开发",{"2":{"22":1,"48":1}}],["parameter",{"2":{"30":1}}],["parameters",{"2":{"30":2}}],["page",{"0":{"3":1,"4":1},"2":{"0":7,"3":1,"58":1,"65":1}}],["p",{"2":{"14":1,"15":3,"16":4,"17":1}}],["primary",{"2":{"58":1}}],["printnode",{"2":{"42":2,"43":2,"44":2,"45":1}}],["print",{"2":{"30":5,"33":3}}],["provides",{"2":{"66":1}}],["provided",{"2":{"0":1,"65":1}}],["probably",{"2":{"30":2}}],["preorder",{"2":{"42":4}}],["prepare",{"2":{"30":2}}],["pred",{"2":{"19":1,"20":1}}],["pre>",{"2":{"0":6}}],["pr",{"2":{"14":1}}]],"serializationVersion":2}';export{e as default};
