import{_ as e,c as t,o as a,V as i}from"./chunks/framework.RLOxJhMo.js";const u=JSON.parse('{"title":"git常用操作","description":"","frontmatter":{},"headers":[],"relativePath":"guide/blog/2023/aboutGit.md","filePath":"guide/blog/2023/aboutGit.md","lastUpdated":null}'),r={name:"guide/blog/2023/aboutGit.md"},o=i('<h1 id="git常用操作" tabindex="-1">git常用操作<a href="https://justin3go.com/%E5%8D%9A%E5%AE%A2/2022/04git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C#git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C" target="_blank" rel="noreferrer"></a> <a class="header-anchor" href="#git常用操作" aria-label="Permalink to &quot;git常用操作[](https://justin3go.com/博客/2022/04git常用操作#git常用操作)&quot;">​</a></h1><h2 id="同步master" tabindex="-1">同步master<a href="https://justin3go.com/%E5%8D%9A%E5%AE%A2/2022/04git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C#%E5%90%8C%E6%AD%A5master" target="_blank" rel="noreferrer"></a> <a class="header-anchor" href="#同步master" aria-label="Permalink to &quot;同步master[](https://justin3go.com/博客/2022/04git常用操作#同步master)&quot;">​</a></h2><ul><li>而如果feat分支有两个提交，然后直接<code>git rebase master</code>，就有可能需要处理两次冲突(假设master分支提交的与feat提交的在同一份文件中)，<code>git add .</code>,<code>git rebase --continue</code>,</li></ul><h2 id="合并多个commit" tabindex="-1">合并多个commit<a href="https://justin3go.com/%E5%8D%9A%E5%AE%A2/2022/04git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C#%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AAcommit" target="_blank" rel="noreferrer"></a> <a class="header-anchor" href="#合并多个commit" aria-label="Permalink to &quot;合并多个commit[](https://justin3go.com/博客/2022/04git常用操作#合并多个commit)&quot;">​</a></h2><ul><li>git log --oneline</li><li>git rebase -i commitHash ：<code>commitHash</code>是commitID，是需要合并的commit的前一个commit节点的ID</li><li>git rebase -i head~2 ：合并最近两次提交</li><li>最后记得使用git push -f 强制推送，而不是使用vscode的同步代码，那个会先拉取。</li><li>rebase的时候，修改冲突后的提交不是使用commit命令，而是执行rebase命令指定 --continue选项。若要取消rebase，指定 --abort选项。</li></ul><h2 id="cherry-pick" tabindex="-1">cherry-pick<a href="https://justin3go.com/%E5%8D%9A%E5%AE%A2/2022/04git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C#cherry-pick" target="_blank" rel="noreferrer"></a> <a class="header-anchor" href="#cherry-pick" aria-label="Permalink to &quot;cherry-pick[](https://justin3go.com/博客/2022/04git常用操作#cherry-pick)&quot;">​</a></h2><p>它的功能是把已经存在的commit进行挑选，然后重新提交。 （今天我记得就是我有分支被我弄乱了，因为我在开发的过程中同步拉取了远程的代码，所以顺序是我提交--&gt;别人提交--&gt;我提交）这时候，使用check-pick就很好的解决了合并提交记录的问题，当然，最好还是不要在开发分支的过程中同步远程master仓库。</p><p>例子： 在<code>master</code>的基础上，<code>test</code>进行了2次提交，<code>normal</code>进行了1次提交。现在想把<code>test</code>的第2次提交 （仅仅是第2次提交，不包含第1次提交）和<code>normal</code>的第1次提交合并到master分支，直接merge分支是行不通的，这样会把两个分支的全部提交都合并到<code>master</code>，用<code>cherry-pick</code>即可完美的解决问题， 如果<code>normal</code>第一次提交的<code>SHA-1</code>值是<code>9b47dd</code>，<code>test</code>第二次提交的值是<code>dd4e49</code>，执行如下命令即可把这两个提交合并到<code>master</code></p><p>sh</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>git cherry-pick 9b47dd dd4e49</span></span></code></pre></div><p>如果有冲突，则需要修改冲突文件，然后添加修改文件到暂存区，命令如下：</p><p>sh</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>git add main.js</span></span></code></pre></div><p>最后执行</p><p>sh</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>git cherry-pick --continue</span></span></code></pre></div><p>cherry-pick后</p><p>最后要说明的是：</p><ul><li>执行完<code>git cherry-pick --continue</code>后不需要commit了，该命令会自动提交</li><li><code>git cherry-pick --abort</code>可以放弃本次<code>cherry-pick</code></li><li><code>git cherry-pick 9b47dd dd4e49</code>和<code>git cherry-pick dd4e49 9b47dd</code>这两个的结果可能会<strong>不一样</strong>，<strong>顺序很重要</strong></li></ul><h2 id="其他" tabindex="-1">其他<a href="https://justin3go.com/%E5%8D%9A%E5%AE%A2/2022/04git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C#%E5%85%B6%E4%BB%96" target="_blank" rel="noreferrer"></a> <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他[](https://justin3go.com/博客/2022/04git常用操作#其他)&quot;">​</a></h2><ul><li>git amend：修改同一个分支最近提交的注解和内容</li><li>在revert可以取消指定的提交内容。使用后面要提到的rebase -i或reset也可以删除提交。但是，不能随便删除已经发布的提交，这时需要通过revert创建要否定的提交。</li><li>在reset可以遗弃不再使用的提交。执行遗弃时，需要根据影响的范围而指定不同的模式，可以指定是否复原索引或工作树的内容。</li><li>在rebase指定i选项，您可以改写、替换、删除或合并提交。</li></ul><h2 id="优秀文章" tabindex="-1">优秀文章<a href="https://justin3go.com/%E5%8D%9A%E5%AE%A2/2022/04git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C#%E4%BC%98%E7%A7%80%E6%96%87%E7%AB%A0" target="_blank" rel="noreferrer"></a> <a class="header-anchor" href="#优秀文章" aria-label="Permalink to &quot;优秀文章[](https://justin3go.com/博客/2022/04git常用操作#优秀文章)&quot;">​</a></h2><ul><li><a href="https://backlog.com/git-tutorial/cn/stepup/stepup1_5.html" target="_blank" rel="noreferrer">猴子都能懂的git入门</a></li><li><a href="https://juejin.cn/post/7064134612129644558" target="_blank" rel="noreferrer">如何优雅解决git 中冲突</a></li><li><a href="https://juejin.cn/post/6844903521993621511" target="_blank" rel="noreferrer">Git提交历史的修改删除合并</a></li><li><a href="https://juejin.cn/post/6844903600976576519" target="_blank" rel="noreferrer">使用git rebase合并多次commit</a></li><li><strong><a href="https://juejin.cn/post/7024043015794589727" target="_blank" rel="noreferrer">前端架构师的 git 功力，你有几成火候？</a></strong></li></ul>',23),c=[o];function s(l,n,d,p,h,g){return a(),t("div",null,c)}const E=e(r,[["render",s]]);export{u as __pageData,E as default};
